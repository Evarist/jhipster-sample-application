{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 2.8.12\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nimport { _DYN_CALL, _DYN_GET_NEXT, _DYN_GET_PLUGIN, _DYN_INITIALIZE, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SET_NEXT_PLUGIN, _DYN_SPAN_ID, _DYN_TEARDOWN, _DYN_TRACE_FLAGS, _DYN_TRACE_ID, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\nimport { createElmNodeData } from \"./DataCacheHelper\";\nimport { arrForEach, isFunction } from \"./HelperFuncs\";\nimport { STR_CORE, STR_PRIORITY, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\nimport { isValidSpanId, isValidTraceId } from \"./W3cTraceParent\";\nvar pluginStateData = createElmNodeData(\"plugin\");\nexport function _getPluginState(plugin) {\n  return pluginStateData.get(plugin, \"state\", {}, true);\n}\n/**\r\n * Initialize the queue of plugins\r\n * @param plugins - The array of plugins to initialize and setting of the next plugin\r\n * @param config The current config for the instance\r\n * @param core THe current core instance\r\n * @param extensions The extensions\r\n */\nexport function initializePlugins(processContext, extensions) {\n  // Set the next plugin and identified the uninitialized plugins\n  var initPlugins = [];\n  var lastPlugin = null;\n  var proxy = processContext[_DYN_GET_NEXT /* @min:%2egetNext */]();\n  var pluginState;\n  while (proxy) {\n    var thePlugin = proxy[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]();\n    if (thePlugin) {\n      if (lastPlugin && isFunction(lastPlugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */]) && isFunction(thePlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\n        // Set this plugin as the next for the previous one\n        lastPlugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](thePlugin);\n      }\n      var isInitialized = false;\n      if (isFunction(thePlugin[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */])) {\n        isInitialized = thePlugin[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]();\n      } else {\n        pluginState = _getPluginState(thePlugin);\n        isInitialized = pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */];\n      }\n\n      if (!isInitialized) {\n        initPlugins[_DYN_PUSH /* @min:%2epush */](thePlugin);\n      }\n      lastPlugin = thePlugin;\n      proxy = proxy[_DYN_GET_NEXT /* @min:%2egetNext */]();\n    }\n  }\n  // Now initialize the plugins\n  arrForEach(initPlugins, function (thePlugin) {\n    var core = processContext[STR_CORE]();\n    thePlugin[_DYN_INITIALIZE /* @min:%2einitialize */](processContext.getCfg(), core, extensions, processContext[_DYN_GET_NEXT /* @min:%2egetNext */]());\n    pluginState = _getPluginState(thePlugin);\n    // Only add the core to the state if the plugin didn't set it (doesn't extent from BaseTelemetryPlugin)\n    if (!thePlugin[STR_CORE] && !pluginState[STR_CORE]) {\n      pluginState[STR_CORE] = core;\n    }\n    pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = true;\n    delete pluginState[_DYN_TEARDOWN /* @min:%2eteardown */];\n  });\n}\n\nexport function sortPlugins(plugins) {\n  // Sort by priority\n  return plugins.sort(function (extA, extB) {\n    var result = 0;\n    if (extB) {\n      var bHasProcess = isFunction(extB[STR_PROCESS_TELEMETRY]);\n      if (isFunction(extA[STR_PROCESS_TELEMETRY])) {\n        result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;\n      } else if (bHasProcess) {\n        result = -1;\n      }\n    } else {\n      result = extA ? 1 : -1;\n    }\n    return result;\n  });\n  // sort complete\n}\n/**\r\n * Teardown / Unload helper to perform teardown/unloading operations for the provided components synchronously or asynchronously, this will call any\r\n * _doTeardown() or _doUnload() functions on the provided components to allow them to finish removal.\r\n * @param components - The components you want to unload\r\n * @param unloadCtx - This is the context that should be used during unloading.\r\n * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.\r\n * @param asyncCallback - An optional callback that the plugin must call if it returns true to inform the caller that it has completed any async unload/teardown operations.\r\n * @returns boolean - true if the plugin has or will call asyncCallback, this allows the plugin to perform any asynchronous operations.\r\n */\nexport function unloadComponents(components, unloadCtx, unloadState, asyncCallback) {\n  var idx = 0;\n  function _doUnload() {\n    while (idx < components[_DYN_LENGTH /* @min:%2elength */]) {\n      var component = components[idx++];\n      if (component) {\n        var func = component._doUnload || component[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */];\n        if (isFunction(func)) {\n          if (func[_DYN_CALL /* @min:%2ecall */](component, unloadCtx, unloadState, _doUnload) === true) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return _doUnload();\n}\n/**\r\n * Creates a IDistributedTraceContext which optionally also \"sets\" the value on a parent\r\n * @param parentCtx - An optional parent distributed trace instance\r\n * @returns A new IDistributedTraceContext instance that uses an internal temporary object\r\n */\nexport function createDistributedTraceContext(parentCtx) {\n  var trace = {};\n  return {\n    getName: function getName() {\n      return trace[_DYN_NAME /* @min:%2ename */];\n    },\n\n    setName: function setName(newValue) {\n      parentCtx && parentCtx.setName(newValue);\n      trace[_DYN_NAME /* @min:%2ename */] = newValue;\n    },\n    getTraceId: function getTraceId() {\n      return trace[_DYN_TRACE_ID /* @min:%2etraceId */];\n    },\n\n    setTraceId: function setTraceId(newValue) {\n      parentCtx && parentCtx.setTraceId(newValue);\n      if (isValidTraceId(newValue)) {\n        trace[_DYN_TRACE_ID /* @min:%2etraceId */] = newValue;\n      }\n    },\n    getSpanId: function getSpanId() {\n      return trace[_DYN_SPAN_ID /* @min:%2espanId */];\n    },\n\n    setSpanId: function setSpanId(newValue) {\n      parentCtx && parentCtx.setSpanId(newValue);\n      if (isValidSpanId(newValue)) {\n        trace[_DYN_SPAN_ID /* @min:%2espanId */] = newValue;\n      }\n    },\n    getTraceFlags: function getTraceFlags() {\n      return trace[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */];\n    },\n\n    setTraceFlags: function setTraceFlags(newTraceFlags) {\n      parentCtx && parentCtx.setTraceFlags(newTraceFlags);\n      trace[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */] = newTraceFlags;\n    }\n  };\n}","map":{"version":3,"names":["_DYN_CALL","_DYN_GET_NEXT","_DYN_GET_PLUGIN","_DYN_INITIALIZE","_DYN_IS_INITIALIZED","_DYN_LENGTH","_DYN_NAME","_DYN_PUSH","_DYN_SET_NEXT_PLUGIN","_DYN_SPAN_ID","_DYN_TEARDOWN","_DYN_TRACE_FLAGS","_DYN_TRACE_ID","_DYN__DO_TEARDOWN","createElmNodeData","arrForEach","isFunction","STR_CORE","STR_PRIORITY","STR_PROCESS_TELEMETRY","isValidSpanId","isValidTraceId","pluginStateData","_getPluginState","plugin","get","initializePlugins","processContext","extensions","initPlugins","lastPlugin","proxy","pluginState","thePlugin","isInitialized","core","getCfg","sortPlugins","plugins","sort","extA","extB","result","bHasProcess","unloadComponents","components","unloadCtx","unloadState","asyncCallback","idx","_doUnload","component","func","createDistributedTraceContext","parentCtx","trace","getName","setName","newValue","getTraceId","setTraceId","getSpanId","setSpanId","getTraceFlags","setTraceFlags","newTraceFlags"],"sources":["/Users/evaristlobo/Documents/GitHub/jhipster-sample-application/client/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/TelemetryHelpers.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nimport { _DYN_CALL, _DYN_GET_NEXT, _DYN_GET_PLUGIN, _DYN_INITIALIZE, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SET_NEXT_PLUGIN, _DYN_SPAN_ID, _DYN_TEARDOWN, _DYN_TRACE_FLAGS, _DYN_TRACE_ID, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\r\nimport { createElmNodeData } from \"./DataCacheHelper\";\r\nimport { arrForEach, isFunction } from \"./HelperFuncs\";\r\nimport { STR_CORE, STR_PRIORITY, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\r\nimport { isValidSpanId, isValidTraceId } from \"./W3cTraceParent\";\r\nvar pluginStateData = createElmNodeData(\"plugin\");\r\nexport function _getPluginState(plugin) {\r\n    return pluginStateData.get(plugin, \"state\", {}, true);\r\n}\r\n/**\r\n * Initialize the queue of plugins\r\n * @param plugins - The array of plugins to initialize and setting of the next plugin\r\n * @param config The current config for the instance\r\n * @param core THe current core instance\r\n * @param extensions The extensions\r\n */\r\nexport function initializePlugins(processContext, extensions) {\r\n    // Set the next plugin and identified the uninitialized plugins\r\n    var initPlugins = [];\r\n    var lastPlugin = null;\r\n    var proxy = processContext[_DYN_GET_NEXT /* @min:%2egetNext */]();\r\n    var pluginState;\r\n    while (proxy) {\r\n        var thePlugin = proxy[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]();\r\n        if (thePlugin) {\r\n            if (lastPlugin &&\r\n                isFunction(lastPlugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */]) &&\r\n                isFunction(thePlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\r\n                // Set this plugin as the next for the previous one\r\n                lastPlugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](thePlugin);\r\n            }\r\n            var isInitialized = false;\r\n            if (isFunction(thePlugin[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */])) {\r\n                isInitialized = thePlugin[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]();\r\n            }\r\n            else {\r\n                pluginState = _getPluginState(thePlugin);\r\n                isInitialized = pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */];\r\n            }\r\n            if (!isInitialized) {\r\n                initPlugins[_DYN_PUSH /* @min:%2epush */](thePlugin);\r\n            }\r\n            lastPlugin = thePlugin;\r\n            proxy = proxy[_DYN_GET_NEXT /* @min:%2egetNext */]();\r\n        }\r\n    }\r\n    // Now initialize the plugins\r\n    arrForEach(initPlugins, function (thePlugin) {\r\n        var core = processContext[STR_CORE]();\r\n        thePlugin[_DYN_INITIALIZE /* @min:%2einitialize */](processContext.getCfg(), core, extensions, processContext[_DYN_GET_NEXT /* @min:%2egetNext */]());\r\n        pluginState = _getPluginState(thePlugin);\r\n        // Only add the core to the state if the plugin didn't set it (doesn't extent from BaseTelemetryPlugin)\r\n        if (!thePlugin[STR_CORE] && !pluginState[STR_CORE]) {\r\n            pluginState[STR_CORE] = core;\r\n        }\r\n        pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = true;\r\n        delete pluginState[_DYN_TEARDOWN /* @min:%2eteardown */];\r\n    });\r\n}\r\nexport function sortPlugins(plugins) {\r\n    // Sort by priority\r\n    return plugins.sort(function (extA, extB) {\r\n        var result = 0;\r\n        if (extB) {\r\n            var bHasProcess = isFunction(extB[STR_PROCESS_TELEMETRY]);\r\n            if (isFunction(extA[STR_PROCESS_TELEMETRY])) {\r\n                result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;\r\n            }\r\n            else if (bHasProcess) {\r\n                result = -1;\r\n            }\r\n        }\r\n        else {\r\n            result = extA ? 1 : -1;\r\n        }\r\n        return result;\r\n    });\r\n    // sort complete\r\n}\r\n/**\r\n * Teardown / Unload helper to perform teardown/unloading operations for the provided components synchronously or asynchronously, this will call any\r\n * _doTeardown() or _doUnload() functions on the provided components to allow them to finish removal.\r\n * @param components - The components you want to unload\r\n * @param unloadCtx - This is the context that should be used during unloading.\r\n * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.\r\n * @param asyncCallback - An optional callback that the plugin must call if it returns true to inform the caller that it has completed any async unload/teardown operations.\r\n * @returns boolean - true if the plugin has or will call asyncCallback, this allows the plugin to perform any asynchronous operations.\r\n */\r\nexport function unloadComponents(components, unloadCtx, unloadState, asyncCallback) {\r\n    var idx = 0;\r\n    function _doUnload() {\r\n        while (idx < components[_DYN_LENGTH /* @min:%2elength */]) {\r\n            var component = components[idx++];\r\n            if (component) {\r\n                var func = component._doUnload || component[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */];\r\n                if (isFunction(func)) {\r\n                    if (func[_DYN_CALL /* @min:%2ecall */](component, unloadCtx, unloadState, _doUnload) === true) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return _doUnload();\r\n}\r\n/**\r\n * Creates a IDistributedTraceContext which optionally also \"sets\" the value on a parent\r\n * @param parentCtx - An optional parent distributed trace instance\r\n * @returns A new IDistributedTraceContext instance that uses an internal temporary object\r\n */\r\nexport function createDistributedTraceContext(parentCtx) {\r\n    var trace = {};\r\n    return {\r\n        getName: function () {\r\n            return trace[_DYN_NAME /* @min:%2ename */];\r\n        },\r\n        setName: function (newValue) {\r\n            parentCtx && parentCtx.setName(newValue);\r\n            trace[_DYN_NAME /* @min:%2ename */] = newValue;\r\n        },\r\n        getTraceId: function () {\r\n            return trace[_DYN_TRACE_ID /* @min:%2etraceId */];\r\n        },\r\n        setTraceId: function (newValue) {\r\n            parentCtx && parentCtx.setTraceId(newValue);\r\n            if (isValidTraceId(newValue)) {\r\n                trace[_DYN_TRACE_ID /* @min:%2etraceId */] = newValue;\r\n            }\r\n        },\r\n        getSpanId: function () {\r\n            return trace[_DYN_SPAN_ID /* @min:%2espanId */];\r\n        },\r\n        setSpanId: function (newValue) {\r\n            parentCtx && parentCtx.setSpanId(newValue);\r\n            if (isValidSpanId(newValue)) {\r\n                trace[_DYN_SPAN_ID /* @min:%2espanId */] = newValue;\r\n            }\r\n        },\r\n        getTraceFlags: function () {\r\n            return trace[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */];\r\n        },\r\n        setTraceFlags: function (newTraceFlags) {\r\n            parentCtx && parentCtx.setTraceFlags(newTraceFlags);\r\n            trace[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */] = newTraceFlags;\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=TelemetryHelpers.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}