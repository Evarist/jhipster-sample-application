{"ast":null,"code":"/*!\n * Microsoft Dynamic Proto Utility, 1.1.9\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nvar _a;\nvar UNDEFINED = \"undefined\";\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar Constructor = 'constructor';\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar Prototype = 'prototype';\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar strFunction = 'function';\n/**\r\n * Used to define the name of the instance function lookup table\r\n * @ignore\r\n */\nvar DynInstFuncTable = '_dynInstFuncs';\n/**\r\n * Name used to tag the dynamic prototype function\r\n * @ignore\r\n */\nvar DynProxyTag = '_isDynProxy';\n/**\r\n * Name added to a prototype to define the dynamic prototype \"class\" name used to lookup the function table\r\n * @ignore\r\n */\nvar DynClassName = '_dynClass';\n/**\r\n * Prefix added to the classname to avoid any name clashes with other instance level properties\r\n * @ignore\r\n */\nvar DynClassNamePrefix = '_dynCls$';\n/**\r\n * A tag which is used to check if we have already to attempted to set the instance function if one is not present\r\n * @ignore\r\n */\nvar DynInstChkTag = '_dynInstChk';\n/**\r\n * A tag which is used to check if we are allows to try and set an instance function is one is not present. Using the same\r\n * tag name as the function level but a different const name for readability only.\r\n */\nvar DynAllowInstChkTag = DynInstChkTag;\n/**\r\n * The global (imported) instances where the global performance options are stored\r\n */\nvar DynProtoDefaultOptions = '_dfOpts';\n/**\r\n * Value used as the name of a class when it cannot be determined\r\n * @ignore\r\n */\nvar UnknownValue = '_unknown_';\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar str__Proto = \"__proto__\";\n/**\r\n * The polyfill version of __proto__ so that it doesn't cause issues for anyone not expecting it to exist\r\n */\nvar DynProtoBaseProto = \"_dyn\" + str__Proto;\n/**\r\n * Runtime Global holder for dynamicProto settings\r\n */\nvar DynProtoGlobalSettings = \"__dynProto$Gbl\";\n/**\r\n * Track the current prototype for IE8 as you can't look back to get the prototype\r\n */\nvar DynProtoCurrent = \"_dynInstProto\";\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar strUseBaseInst = 'useBaseInst';\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar strSetInstFuncs = 'setInstFuncs';\nvar Obj = Object;\n/**\r\n * Pre-lookup to check if we are running on a modern browser (i.e. not IE8)\r\n * @ignore\r\n */\nvar _objGetPrototypeOf = Obj[\"getPrototypeOf\"];\n/**\r\n * Pre-lookup to check for the existence of this function\r\n */\nvar _objGetOwnProps = Obj[\"getOwnPropertyNames\"];\n/**\r\n * Gets the runtime global reference\r\n * @returns\r\n */\nfunction _getGlobal() {\n  var result;\n  if (typeof globalThis !== UNDEFINED) {\n    result = globalThis;\n  }\n  if (!result && typeof self !== UNDEFINED) {\n    result = self;\n  }\n  if (!result && typeof window !== UNDEFINED) {\n    result = window;\n  }\n  if (!result && typeof global !== UNDEFINED) {\n    result = global;\n  }\n  return result || {};\n}\n// Since 1.1.7 moving these to the runtime global to work around mixed version and module issues\n// See Issue https://github.com/microsoft/DynamicProto-JS/issues/57 for details\nvar _gbl = _getGlobal();\nvar _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {\n  o: (_a = {}, _a[strSetInstFuncs] = true, _a[strUseBaseInst] = true, _a),\n  n: 1000 // Start new global index @ 1000 so we \"fix\" some cases when mixed with 1.1.6 or earlier\n});\n/**\r\n * Helper to check if the object contains a property of the name\r\n * @ignore\r\n */\nfunction _hasOwnProperty(obj, prop) {\n  return obj && Obj[Prototype].hasOwnProperty.call(obj, prop);\n}\n/**\r\n * Helper used to check whether the target is an Object prototype or Array prototype\r\n * @ignore\r\n */\nfunction _isObjectOrArrayPrototype(target) {\n  return target && (target === Obj[Prototype] || target === Array[Prototype]);\n}\n/**\r\n * Helper used to check whether the target is an Object prototype, Array prototype or Function prototype\r\n * @ignore\r\n */\nfunction _isObjectArrayOrFunctionPrototype(target) {\n  return _isObjectOrArrayPrototype(target) || target === Function[Prototype];\n}\n/**\r\n * Helper used to get the prototype of the target object as getPrototypeOf is not available in an ES3 environment.\r\n * @ignore\r\n */\nfunction _getObjProto(target) {\n  var newProto;\n  if (target) {\n    // This method doesn't exist in older browsers (e.g. IE8)\n    if (_objGetPrototypeOf) {\n      return _objGetPrototypeOf(target);\n    }\n    var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);\n    // Using the pre-calculated value as IE8 doesn't support looking up the prototype of a prototype and thus fails for more than 1 base class\n    newProto = target[DynProtoBaseProto] || curProto;\n    if (!_hasOwnProperty(target, DynProtoBaseProto)) {\n      // As this prototype doesn't have this property then this is from an inherited class so newProto is the base to return so save it\n      // so we can look it up value (which for a multiple hierarchy dynamicProto will be the base class)\n      delete target[DynProtoCurrent]; // Delete any current value allocated to this instance so we pick up the value from prototype hierarchy\n      newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];\n      target[DynProtoCurrent] = curProto;\n    }\n  }\n  return newProto;\n}\n/**\r\n * Helper to get the properties of an object, including none enumerable ones as functions on a prototype in ES6\r\n * are not enumerable.\r\n * @param target\r\n */\nfunction _forEachProp(target, func) {\n  var props = [];\n  if (_objGetOwnProps) {\n    props = _objGetOwnProps(target);\n  } else {\n    for (var name_1 in target) {\n      if (typeof name_1 === \"string\" && _hasOwnProperty(target, name_1)) {\n        props.push(name_1);\n      }\n    }\n  }\n  if (props && props.length > 0) {\n    for (var lp = 0; lp < props.length; lp++) {\n      func(props[lp]);\n    }\n  }\n}\n/**\r\n * Helper function to check whether the provided function name is a potential candidate for dynamic\r\n * callback and prototype generation.\r\n * @param target The target object, may be a prototype or class object\r\n * @param funcName The function name\r\n * @param skipOwn Skips the check for own property\r\n * @ignore\r\n */\nfunction _isDynamicCandidate(target, funcName, skipOwn) {\n  return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || _hasOwnProperty(target, funcName));\n}\n/**\r\n * Helper to throw a TypeError exception\r\n * @param message the message\r\n * @ignore\r\n */\nfunction _throwTypeError(message) {\n  throw new TypeError(\"DynamicProto: \" + message);\n}\n/**\r\n * Returns a collection of the instance functions that are defined directly on the thisTarget object, it does\r\n * not return any inherited functions\r\n * @param thisTarget The object to get the instance functions from\r\n * @ignore\r\n */\nfunction _getInstanceFuncs(thisTarget) {\n  // Get the base proto\n  var instFuncs = {};\n  // Save any existing instance functions\n  _forEachProp(thisTarget, function (name) {\n    // Don't include any dynamic prototype instances - as we only want the real functions\n    if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {\n      // Create an instance callback for passing the base function to the caller\n      instFuncs[name] = thisTarget[name];\n    }\n  });\n  return instFuncs;\n}\n/**\r\n * Returns whether the value is included in the array\r\n * @param values The array of values\r\n * @param value  The value\r\n */\nfunction _hasVisited(values, value) {\n  for (var lp = values.length - 1; lp >= 0; lp--) {\n    if (values[lp] === value) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\r\n * Returns an object that contains callback functions for all \"base/super\" functions, this is used to \"save\"\r\n * enabling calling super.xxx() functions without requiring that the base \"class\" has defined a prototype references\r\n * @param target The current instance\r\n * @ignore\r\n */\nfunction _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {\n  function _instFuncProxy(target, funcHost, funcName) {\n    var theFunc = funcHost[funcName];\n    if (theFunc[DynProxyTag] && useBaseInst) {\n      // grab and reuse the hosted looking function (if available) otherwise the original passed function\n      var instFuncTable = target[DynInstFuncTable] || {};\n      if (instFuncTable[DynAllowInstChkTag] !== false) {\n        theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;\n      }\n    }\n    return function () {\n      // eslint-disable-next-line prefer-rest-params\n      return theFunc.apply(target, arguments);\n    };\n  }\n  // Start creating a new baseFuncs by creating proxies for the instance functions (as they may get replaced)\n  var baseFuncs = {};\n  _forEachProp(instFuncs, function (name) {\n    // Create an instance callback for passing the base function to the caller\n    baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);\n  });\n  // Get the base prototype functions\n  var baseProto = _getObjProto(classProto);\n  var visited = [];\n  // Don't include base object functions for Object, Array or Function\n  while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {\n    // look for prototype functions\n    _forEachProp(baseProto, function (name) {\n      // Don't include any dynamic prototype instances - as we only want the real functions\n      // For IE 7/8 the prototype lookup doesn't provide the full chain so we need to bypass the \n      // hasOwnProperty check we get all of the methods, main difference is that IE7/8 doesn't return\n      // the Object prototype methods while bypassing the check\n      if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {\n        // Create an instance callback for passing the base function to the caller\n        baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);\n      }\n    });\n    // We need to find all possible functions that might be overloaded by walking the entire prototype chain\n    // This avoids the caller from needing to check whether it's direct base class implements the function or not\n    // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\n    visited.push(baseProto);\n    baseProto = _getObjProto(baseProto);\n  }\n  return baseFuncs;\n}\nfunction _getInstFunc(target, funcName, proto, currentDynProtoProxy) {\n  var instFunc = null;\n  // We need to check whether the class name is defined directly on this prototype otherwise\n  // it will walk the proto chain and return any parent proto classname.\n  if (target && _hasOwnProperty(proto, DynClassName)) {\n    var instFuncTable = target[DynInstFuncTable] || {};\n    instFunc = (instFuncTable[proto[DynClassName]] || {})[funcName];\n    if (!instFunc) {\n      // Avoid stack overflow from recursive calling the same function\n      _throwTypeError(\"Missing [\" + funcName + \"] \" + strFunction);\n    }\n    // We have the instance function, lets check it we can speed up further calls\n    // by adding the instance function back directly on the instance (avoiding the dynamic func lookup)\n    if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {\n      // If the instance already has an instance function we can't replace it\n      var canAddInst = !_hasOwnProperty(target, funcName);\n      // Get current prototype\n      var objProto = _getObjProto(target);\n      var visited = [];\n      // Lookup the function starting at the top (instance level prototype) and traverse down, if the first matching function\n      // if nothing is found or if the first hit is a dynamic proto instance then we can safely add an instance shortcut\n      while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {\n        var protoFunc = objProto[funcName];\n        if (protoFunc) {\n          canAddInst = protoFunc === currentDynProtoProxy;\n          break;\n        }\n        // We need to find all possible initial functions to ensure that we don't bypass a valid override function\n        visited.push(objProto);\n        objProto = _getObjProto(objProto);\n      }\n      try {\n        if (canAddInst) {\n          // This instance doesn't have an instance func and the class hierarchy does have a higher level prototype version\n          // so it's safe to directly assign for any subsequent calls (for better performance)\n          target[funcName] = instFunc;\n        }\n        // Block further attempts to set the instance function for any\n        instFunc[DynInstChkTag] = 1;\n      } catch (e) {\n        // Don't crash if the object is readonly or the runtime doesn't allow changing this\n        // And set a flag so we don't try again for any function\n        instFuncTable[DynAllowInstChkTag] = false;\n      }\n    }\n  }\n  return instFunc;\n}\nfunction _getProtoFunc(funcName, proto, currentDynProtoProxy) {\n  var protoFunc = proto[funcName];\n  // Check that the prototype function is not a self reference -- try to avoid stack overflow!\n  if (protoFunc === currentDynProtoProxy) {\n    // It is so lookup the base prototype\n    protoFunc = _getObjProto(proto)[funcName];\n  }\n  if (typeof protoFunc !== strFunction) {\n    _throwTypeError(\"[\" + funcName + \"] is not a \" + strFunction);\n  }\n  return protoFunc;\n}\n/**\r\n * Add the required dynamic prototype methods to the the class prototype\r\n * @param proto - The class prototype\r\n * @param className - The instance classname\r\n * @param target - The target instance\r\n * @param baseInstFuncs - The base instance functions\r\n * @param setInstanceFunc - Flag to allow prototype function to reset the instance function if one does not exist\r\n * @ignore\r\n */\nfunction _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {\n  function _createDynamicPrototype(proto, funcName) {\n    var dynProtoProxy = function dynProtoProxy() {\n      // Use the instance or prototype function\n      var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);\n      // eslint-disable-next-line prefer-rest-params\n      return instFunc.apply(this, arguments);\n    };\n    // Tag this function as a proxy to support replacing dynamic proxy elements (primary use case is for unit testing\n    // via which can dynamically replace the prototype function reference)\n    dynProtoProxy[DynProxyTag] = 1;\n    return dynProtoProxy;\n  }\n  if (!_isObjectOrArrayPrototype(proto)) {\n    var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || {};\n    var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || {}; // fetch and assign if as it may not exist yet\n    // Set whether we are allow to lookup instances, if someone has set to false then do not re-enable\n    if (instFuncTable[DynAllowInstChkTag] !== false) {\n      instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;\n    }\n    _forEachProp(target, function (name) {\n      // Only add overridden functions\n      if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {\n        // Save the instance Function to the lookup table and remove it from the instance as it's not a dynamic proto function\n        instFuncs_1[name] = target[name];\n        delete target[name];\n        // Add a dynamic proto if one doesn't exist or if a prototype function exists and it's not a dynamic one\n        if (!_hasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) {\n          proto[name] = _createDynamicPrototype(proto, name);\n        }\n      }\n    });\n  }\n}\n/**\r\n * Checks whether the passed prototype object appears to be correct by walking the prototype hierarchy of the instance\r\n * @param classProto The class prototype instance\r\n * @param thisTarget The current instance that will be checked whether the passed prototype instance is in the hierarchy\r\n * @ignore\r\n */\nfunction _checkPrototype(classProto, thisTarget) {\n  // This method doesn't existing in older browsers (e.g. IE8)\n  if (_objGetPrototypeOf) {\n    // As this is primarily a coding time check, don't bother checking if running in IE8 or lower\n    var visited = [];\n    var thisProto = _getObjProto(thisTarget);\n    while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {\n      if (thisProto === classProto) {\n        return true;\n      }\n      // This avoids the caller from needing to check whether it's direct base class implements the function or not\n      // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\n      visited.push(thisProto);\n      thisProto = _getObjProto(thisProto);\n    }\n    return false;\n  }\n  // If objGetPrototypeOf doesn't exist then just assume everything is ok.\n  return true;\n}\n/**\r\n * Gets the current prototype name using the ES6 name if available otherwise falling back to a use unknown as the name.\r\n * It's not critical for this to return a name, it's used to decorate the generated unique name for easier debugging only.\r\n * @param target\r\n * @param unknownValue\r\n * @ignore\r\n */\nfunction _getObjName(target, unknownValue) {\n  if (_hasOwnProperty(target, Prototype)) {\n    // Look like a prototype\n    return target.name || unknownValue || UnknownValue;\n  }\n  return ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;\n}\n/**\r\n * Helper function when creating dynamic (inline) functions for classes, this helper performs the following tasks :-\r\n * - Saves references to all defined base class functions\r\n * - Calls the delegateFunc with the current target (this) and a base object reference that can be used to call all \"super\" functions.\r\n * - Will populate the class prototype for all overridden functions to support class extension that call the prototype instance.\r\n * Callers should use this helper when declaring all function within the constructor of a class, as mentioned above the delegateFunc is\r\n * passed both the target \"this\" and an object that can be used to call any base (super) functions, using this based object in place of\r\n * super.XXX() (which gets expanded to _super.prototype.XXX()) provides a better minification outcome and also ensures the correct \"this\"\r\n * context is maintained as TypeScript creates incorrect references using super.XXXX() for dynamically defined functions i.e. Functions\r\n * defined in the constructor or some other function (rather than declared as complete typescript functions).\r\n * ### Usage\r\n * ```typescript\r\n * import dynamicProto from \"@microsoft/dynamicproto-js\";\r\n * class ExampleClass extends BaseClass {\r\n *     constructor() {\r\n *         dynamicProto(ExampleClass, this, (_self, base) => {\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.newFunc = () => {\r\n *                 // Access any \"this\" instance property\r\n *                 if (_self.someProperty) {\r\n *                     ...\r\n *                 }\r\n *             }\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.myFunction = () => {\r\n *                 // Access any \"this\" instance property\r\n *                 if (_self.someProperty) {\r\n *                     // Call the base version of the function that we are overriding\r\n *                     base.myFunction();\r\n *                 }\r\n *                 ...\r\n *             }\r\n *             _self.initialize = () => {\r\n *                 ...\r\n *             }\r\n *             // Warnings: While the following will work as _self is simply a reference to\r\n *             // this, if anyone overrides myFunction() the overridden will be called first\r\n *             // as the normal JavaScript method resolution will occur and the defined\r\n *             // _self.initialize() function is actually gets removed from the instance and\r\n *             // a proxy prototype version is created to reference the created method.\r\n *             _self.initialize();\r\n *         });\r\n *     }\r\n * }\r\n * ```\r\n * @typeparam DPType This is the generic type of the class, used to keep intellisense valid\r\n * @typeparam DPCls The type that contains the prototype of the current class\r\n * @param theClass - This is the current class instance which contains the prototype for the current class\r\n * @param target - The current \"this\" (target) reference, when the class has been extended this.prototype will not be the 'theClass' value.\r\n * @param delegateFunc - The callback function (closure) that will create the dynamic function\r\n * @param options - Additional options to configure how the dynamic prototype operates\r\n */\nfunction dynamicProto(theClass, target, delegateFunc, options) {\n  // Make sure that the passed theClass argument looks correct\n  if (!_hasOwnProperty(theClass, Prototype)) {\n    _throwTypeError(\"theClass is an invalid class definition.\");\n  }\n  // Quick check to make sure that the passed theClass argument looks correct (this is a common copy/paste error)\n  var classProto = theClass[Prototype];\n  if (!_checkPrototype(classProto, target)) {\n    _throwTypeError(\"[\" + _getObjName(theClass) + \"] not in hierarchy of [\" + _getObjName(target) + \"]\");\n  }\n  var className = null;\n  if (_hasOwnProperty(classProto, DynClassName)) {\n    // Only grab the class name if it's defined on this prototype (i.e. don't walk the prototype chain)\n    className = classProto[DynClassName];\n  } else {\n    // As not all browser support name on the prototype creating a unique dynamic one if we have not already\n    // assigned one, so we can use a simple string as the lookup rather than an object for the dynamic instance\n    // function table lookup.\n    className = DynClassNamePrefix + _getObjName(theClass, \"_\") + \"$\" + _gblInst.n;\n    _gblInst.n++;\n    classProto[DynClassName] = className;\n  }\n  var perfOptions = dynamicProto[DynProtoDefaultOptions];\n  var useBaseInst = !!perfOptions[strUseBaseInst];\n  if (useBaseInst && options && options[strUseBaseInst] !== undefined) {\n    useBaseInst = !!options[strUseBaseInst];\n  }\n  // Get the current instance functions\n  var instFuncs = _getInstanceFuncs(target);\n  // Get all of the functions for any base instance (before they are potentially overridden)\n  var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);\n  // Execute the delegate passing in both the current target \"this\" and \"base\" function references\n  // Note casting the same type as we don't actually have the base class here and this will provide some intellisense support\n  delegateFunc(target, baseFuncs);\n  // Don't allow setting instance functions for older IE instances\n  var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];\n  if (setInstanceFunc && options) {\n    setInstanceFunc = !!options[strSetInstFuncs];\n  }\n  // Populate the Prototype for any overridden instance functions\n  _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);\n}\n/**\r\n * Exposes the default global options to allow global configuration, if the global values are disabled these will override\r\n * any passed values. This is primarily exposed to support unit-testing without the need for individual classes to expose\r\n * their internal usage of dynamic proto.\r\n */\ndynamicProto[DynProtoDefaultOptions] = _gblInst.o;\nexport { dynamicProto as default };","map":{"version":3,"names":["_a","UNDEFINED","Constructor","Prototype","strFunction","DynInstFuncTable","DynProxyTag","DynClassName","DynClassNamePrefix","DynInstChkTag","DynAllowInstChkTag","DynProtoDefaultOptions","UnknownValue","str__Proto","DynProtoBaseProto","DynProtoGlobalSettings","DynProtoCurrent","strUseBaseInst","strSetInstFuncs","Obj","Object","_objGetPrototypeOf","_objGetOwnProps","_getGlobal","result","globalThis","self","window","global","_gbl","_gblInst","o","n","_hasOwnProperty","obj","prop","hasOwnProperty","call","_isObjectOrArrayPrototype","target","Array","_isObjectArrayOrFunctionPrototype","Function","_getObjProto","newProto","curProto","_forEachProp","func","props","name_1","push","length","lp","_isDynamicCandidate","funcName","skipOwn","_throwTypeError","message","TypeError","_getInstanceFuncs","thisTarget","instFuncs","name","_hasVisited","values","value","_getBaseFuncs","classProto","useBaseInst","_instFuncProxy","funcHost","theFunc","instFuncTable","apply","arguments","baseFuncs","baseProto","visited","_getInstFunc","proto","currentDynProtoProxy","instFunc","canAddInst","objProto","protoFunc","e","_getProtoFunc","_populatePrototype","className","baseInstFuncs","setInstanceFunc","_createDynamicPrototype","dynProtoProxy","instFuncs_1","_checkPrototype","thisProto","_getObjName","unknownValue","dynamicProto","theClass","delegateFunc","options","perfOptions","undefined"],"sources":["/Users/evaristlobo/Documents/GitHub/jhipster-sample-application/client/node_modules/@microsoft/dynamicproto-js/lib/out/lib/src/DynamicProto.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nvar _a;\r\n;\r\nvar UNDEFINED = \"undefined\";\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar Constructor = 'constructor';\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar Prototype = 'prototype';\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar strFunction = 'function';\r\n/**\r\n * Used to define the name of the instance function lookup table\r\n * @ignore\r\n */\r\nvar DynInstFuncTable = '_dynInstFuncs';\r\n/**\r\n * Name used to tag the dynamic prototype function\r\n * @ignore\r\n */\r\nvar DynProxyTag = '_isDynProxy';\r\n/**\r\n * Name added to a prototype to define the dynamic prototype \"class\" name used to lookup the function table\r\n * @ignore\r\n */\r\nvar DynClassName = '_dynClass';\r\n/**\r\n * Prefix added to the classname to avoid any name clashes with other instance level properties\r\n * @ignore\r\n */\r\nvar DynClassNamePrefix = '_dynCls$';\r\n/**\r\n * A tag which is used to check if we have already to attempted to set the instance function if one is not present\r\n * @ignore\r\n */\r\nvar DynInstChkTag = '_dynInstChk';\r\n/**\r\n * A tag which is used to check if we are allows to try and set an instance function is one is not present. Using the same\r\n * tag name as the function level but a different const name for readability only.\r\n */\r\nvar DynAllowInstChkTag = DynInstChkTag;\r\n/**\r\n * The global (imported) instances where the global performance options are stored\r\n */\r\nvar DynProtoDefaultOptions = '_dfOpts';\r\n/**\r\n * Value used as the name of a class when it cannot be determined\r\n * @ignore\r\n */\r\nvar UnknownValue = '_unknown_';\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar str__Proto = \"__proto__\";\r\n/**\r\n * The polyfill version of __proto__ so that it doesn't cause issues for anyone not expecting it to exist\r\n */\r\nvar DynProtoBaseProto = \"_dyn\" + str__Proto;\r\n/**\r\n * Runtime Global holder for dynamicProto settings\r\n */\r\nvar DynProtoGlobalSettings = \"__dynProto$Gbl\";\r\n/**\r\n * Track the current prototype for IE8 as you can't look back to get the prototype\r\n */\r\nvar DynProtoCurrent = \"_dynInstProto\";\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar strUseBaseInst = 'useBaseInst';\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nvar strSetInstFuncs = 'setInstFuncs';\r\nvar Obj = Object;\r\n/**\r\n * Pre-lookup to check if we are running on a modern browser (i.e. not IE8)\r\n * @ignore\r\n */\r\nvar _objGetPrototypeOf = Obj[\"getPrototypeOf\"];\r\n/**\r\n * Pre-lookup to check for the existence of this function\r\n */\r\nvar _objGetOwnProps = Obj[\"getOwnPropertyNames\"];\r\n/**\r\n * Gets the runtime global reference\r\n * @returns\r\n */\r\nfunction _getGlobal() {\r\n    var result;\r\n    if (typeof globalThis !== UNDEFINED) {\r\n        result = globalThis;\r\n    }\r\n    if (!result && typeof self !== UNDEFINED) {\r\n        result = self;\r\n    }\r\n    if (!result && typeof window !== UNDEFINED) {\r\n        result = window;\r\n    }\r\n    if (!result && typeof global !== UNDEFINED) {\r\n        result = global;\r\n    }\r\n    return result || {};\r\n}\r\n// Since 1.1.7 moving these to the runtime global to work around mixed version and module issues\r\n// See Issue https://github.com/microsoft/DynamicProto-JS/issues/57 for details\r\nvar _gbl = _getGlobal();\r\nvar _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {\r\n    o: (_a = {},\r\n        _a[strSetInstFuncs] = true,\r\n        _a[strUseBaseInst] = true,\r\n        _a),\r\n    n: 1000 // Start new global index @ 1000 so we \"fix\" some cases when mixed with 1.1.6 or earlier\r\n});\r\n/**\r\n * Helper to check if the object contains a property of the name\r\n * @ignore\r\n */\r\nfunction _hasOwnProperty(obj, prop) {\r\n    return obj && Obj[Prototype].hasOwnProperty.call(obj, prop);\r\n}\r\n/**\r\n * Helper used to check whether the target is an Object prototype or Array prototype\r\n * @ignore\r\n */\r\nfunction _isObjectOrArrayPrototype(target) {\r\n    return target && (target === Obj[Prototype] || target === Array[Prototype]);\r\n}\r\n/**\r\n * Helper used to check whether the target is an Object prototype, Array prototype or Function prototype\r\n * @ignore\r\n */\r\nfunction _isObjectArrayOrFunctionPrototype(target) {\r\n    return _isObjectOrArrayPrototype(target) || target === Function[Prototype];\r\n}\r\n/**\r\n * Helper used to get the prototype of the target object as getPrototypeOf is not available in an ES3 environment.\r\n * @ignore\r\n */\r\nfunction _getObjProto(target) {\r\n    var newProto;\r\n    if (target) {\r\n        // This method doesn't exist in older browsers (e.g. IE8)\r\n        if (_objGetPrototypeOf) {\r\n            return _objGetPrototypeOf(target);\r\n        }\r\n        var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);\r\n        // Using the pre-calculated value as IE8 doesn't support looking up the prototype of a prototype and thus fails for more than 1 base class\r\n        newProto = target[DynProtoBaseProto] || curProto;\r\n        if (!_hasOwnProperty(target, DynProtoBaseProto)) {\r\n            // As this prototype doesn't have this property then this is from an inherited class so newProto is the base to return so save it\r\n            // so we can look it up value (which for a multiple hierarchy dynamicProto will be the base class)\r\n            delete target[DynProtoCurrent]; // Delete any current value allocated to this instance so we pick up the value from prototype hierarchy\r\n            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];\r\n            target[DynProtoCurrent] = curProto;\r\n        }\r\n    }\r\n    return newProto;\r\n}\r\n/**\r\n * Helper to get the properties of an object, including none enumerable ones as functions on a prototype in ES6\r\n * are not enumerable.\r\n * @param target\r\n */\r\nfunction _forEachProp(target, func) {\r\n    var props = [];\r\n    if (_objGetOwnProps) {\r\n        props = _objGetOwnProps(target);\r\n    }\r\n    else {\r\n        for (var name_1 in target) {\r\n            if (typeof name_1 === \"string\" && _hasOwnProperty(target, name_1)) {\r\n                props.push(name_1);\r\n            }\r\n        }\r\n    }\r\n    if (props && props.length > 0) {\r\n        for (var lp = 0; lp < props.length; lp++) {\r\n            func(props[lp]);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Helper function to check whether the provided function name is a potential candidate for dynamic\r\n * callback and prototype generation.\r\n * @param target The target object, may be a prototype or class object\r\n * @param funcName The function name\r\n * @param skipOwn Skips the check for own property\r\n * @ignore\r\n */\r\nfunction _isDynamicCandidate(target, funcName, skipOwn) {\r\n    return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || _hasOwnProperty(target, funcName)));\r\n}\r\n/**\r\n * Helper to throw a TypeError exception\r\n * @param message the message\r\n * @ignore\r\n */\r\nfunction _throwTypeError(message) {\r\n    throw new TypeError(\"DynamicProto: \" + message);\r\n}\r\n/**\r\n * Returns a collection of the instance functions that are defined directly on the thisTarget object, it does\r\n * not return any inherited functions\r\n * @param thisTarget The object to get the instance functions from\r\n * @ignore\r\n */\r\nfunction _getInstanceFuncs(thisTarget) {\r\n    // Get the base proto\r\n    var instFuncs = {};\r\n    // Save any existing instance functions\r\n    _forEachProp(thisTarget, function (name) {\r\n        // Don't include any dynamic prototype instances - as we only want the real functions\r\n        if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {\r\n            // Create an instance callback for passing the base function to the caller\r\n            instFuncs[name] = thisTarget[name];\r\n        }\r\n    });\r\n    return instFuncs;\r\n}\r\n/**\r\n * Returns whether the value is included in the array\r\n * @param values The array of values\r\n * @param value  The value\r\n */\r\nfunction _hasVisited(values, value) {\r\n    for (var lp = values.length - 1; lp >= 0; lp--) {\r\n        if (values[lp] === value) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns an object that contains callback functions for all \"base/super\" functions, this is used to \"save\"\r\n * enabling calling super.xxx() functions without requiring that the base \"class\" has defined a prototype references\r\n * @param target The current instance\r\n * @ignore\r\n */\r\nfunction _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {\r\n    function _instFuncProxy(target, funcHost, funcName) {\r\n        var theFunc = funcHost[funcName];\r\n        if (theFunc[DynProxyTag] && useBaseInst) {\r\n            // grab and reuse the hosted looking function (if available) otherwise the original passed function\r\n            var instFuncTable = target[DynInstFuncTable] || {};\r\n            if (instFuncTable[DynAllowInstChkTag] !== false) {\r\n                theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;\r\n            }\r\n        }\r\n        return function () {\r\n            // eslint-disable-next-line prefer-rest-params\r\n            return theFunc.apply(target, arguments);\r\n        };\r\n    }\r\n    // Start creating a new baseFuncs by creating proxies for the instance functions (as they may get replaced)\r\n    var baseFuncs = {};\r\n    _forEachProp(instFuncs, function (name) {\r\n        // Create an instance callback for passing the base function to the caller\r\n        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);\r\n    });\r\n    // Get the base prototype functions\r\n    var baseProto = _getObjProto(classProto);\r\n    var visited = [];\r\n    // Don't include base object functions for Object, Array or Function\r\n    while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {\r\n        // look for prototype functions\r\n        _forEachProp(baseProto, function (name) {\r\n            // Don't include any dynamic prototype instances - as we only want the real functions\r\n            // For IE 7/8 the prototype lookup doesn't provide the full chain so we need to bypass the \r\n            // hasOwnProperty check we get all of the methods, main difference is that IE7/8 doesn't return\r\n            // the Object prototype methods while bypassing the check\r\n            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {\r\n                // Create an instance callback for passing the base function to the caller\r\n                baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);\r\n            }\r\n        });\r\n        // We need to find all possible functions that might be overloaded by walking the entire prototype chain\r\n        // This avoids the caller from needing to check whether it's direct base class implements the function or not\r\n        // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\r\n        visited.push(baseProto);\r\n        baseProto = _getObjProto(baseProto);\r\n    }\r\n    return baseFuncs;\r\n}\r\nfunction _getInstFunc(target, funcName, proto, currentDynProtoProxy) {\r\n    var instFunc = null;\r\n    // We need to check whether the class name is defined directly on this prototype otherwise\r\n    // it will walk the proto chain and return any parent proto classname.\r\n    if (target && _hasOwnProperty(proto, DynClassName)) {\r\n        var instFuncTable = target[DynInstFuncTable] || {};\r\n        instFunc = (instFuncTable[proto[DynClassName]] || {})[funcName];\r\n        if (!instFunc) {\r\n            // Avoid stack overflow from recursive calling the same function\r\n            _throwTypeError(\"Missing [\" + funcName + \"] \" + strFunction);\r\n        }\r\n        // We have the instance function, lets check it we can speed up further calls\r\n        // by adding the instance function back directly on the instance (avoiding the dynamic func lookup)\r\n        if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {\r\n            // If the instance already has an instance function we can't replace it\r\n            var canAddInst = !_hasOwnProperty(target, funcName);\r\n            // Get current prototype\r\n            var objProto = _getObjProto(target);\r\n            var visited = [];\r\n            // Lookup the function starting at the top (instance level prototype) and traverse down, if the first matching function\r\n            // if nothing is found or if the first hit is a dynamic proto instance then we can safely add an instance shortcut\r\n            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {\r\n                var protoFunc = objProto[funcName];\r\n                if (protoFunc) {\r\n                    canAddInst = (protoFunc === currentDynProtoProxy);\r\n                    break;\r\n                }\r\n                // We need to find all possible initial functions to ensure that we don't bypass a valid override function\r\n                visited.push(objProto);\r\n                objProto = _getObjProto(objProto);\r\n            }\r\n            try {\r\n                if (canAddInst) {\r\n                    // This instance doesn't have an instance func and the class hierarchy does have a higher level prototype version\r\n                    // so it's safe to directly assign for any subsequent calls (for better performance)\r\n                    target[funcName] = instFunc;\r\n                }\r\n                // Block further attempts to set the instance function for any\r\n                instFunc[DynInstChkTag] = 1;\r\n            }\r\n            catch (e) {\r\n                // Don't crash if the object is readonly or the runtime doesn't allow changing this\r\n                // And set a flag so we don't try again for any function\r\n                instFuncTable[DynAllowInstChkTag] = false;\r\n            }\r\n        }\r\n    }\r\n    return instFunc;\r\n}\r\nfunction _getProtoFunc(funcName, proto, currentDynProtoProxy) {\r\n    var protoFunc = proto[funcName];\r\n    // Check that the prototype function is not a self reference -- try to avoid stack overflow!\r\n    if (protoFunc === currentDynProtoProxy) {\r\n        // It is so lookup the base prototype\r\n        protoFunc = _getObjProto(proto)[funcName];\r\n    }\r\n    if (typeof protoFunc !== strFunction) {\r\n        _throwTypeError(\"[\" + funcName + \"] is not a \" + strFunction);\r\n    }\r\n    return protoFunc;\r\n}\r\n/**\r\n * Add the required dynamic prototype methods to the the class prototype\r\n * @param proto - The class prototype\r\n * @param className - The instance classname\r\n * @param target - The target instance\r\n * @param baseInstFuncs - The base instance functions\r\n * @param setInstanceFunc - Flag to allow prototype function to reset the instance function if one does not exist\r\n * @ignore\r\n */\r\nfunction _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {\r\n    function _createDynamicPrototype(proto, funcName) {\r\n        var dynProtoProxy = function () {\r\n            // Use the instance or prototype function\r\n            var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);\r\n            // eslint-disable-next-line prefer-rest-params\r\n            return instFunc.apply(this, arguments);\r\n        };\r\n        // Tag this function as a proxy to support replacing dynamic proxy elements (primary use case is for unit testing\r\n        // via which can dynamically replace the prototype function reference)\r\n        dynProtoProxy[DynProxyTag] = 1;\r\n        return dynProtoProxy;\r\n    }\r\n    if (!_isObjectOrArrayPrototype(proto)) {\r\n        var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || {};\r\n        var instFuncs_1 = instFuncTable[className] = (instFuncTable[className] || {}); // fetch and assign if as it may not exist yet\r\n        // Set whether we are allow to lookup instances, if someone has set to false then do not re-enable\r\n        if (instFuncTable[DynAllowInstChkTag] !== false) {\r\n            instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;\r\n        }\r\n        _forEachProp(target, function (name) {\r\n            // Only add overridden functions\r\n            if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {\r\n                // Save the instance Function to the lookup table and remove it from the instance as it's not a dynamic proto function\r\n                instFuncs_1[name] = target[name];\r\n                delete target[name];\r\n                // Add a dynamic proto if one doesn't exist or if a prototype function exists and it's not a dynamic one\r\n                if (!_hasOwnProperty(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {\r\n                    proto[name] = _createDynamicPrototype(proto, name);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Checks whether the passed prototype object appears to be correct by walking the prototype hierarchy of the instance\r\n * @param classProto The class prototype instance\r\n * @param thisTarget The current instance that will be checked whether the passed prototype instance is in the hierarchy\r\n * @ignore\r\n */\r\nfunction _checkPrototype(classProto, thisTarget) {\r\n    // This method doesn't existing in older browsers (e.g. IE8)\r\n    if (_objGetPrototypeOf) {\r\n        // As this is primarily a coding time check, don't bother checking if running in IE8 or lower\r\n        var visited = [];\r\n        var thisProto = _getObjProto(thisTarget);\r\n        while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {\r\n            if (thisProto === classProto) {\r\n                return true;\r\n            }\r\n            // This avoids the caller from needing to check whether it's direct base class implements the function or not\r\n            // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\r\n            visited.push(thisProto);\r\n            thisProto = _getObjProto(thisProto);\r\n        }\r\n        return false;\r\n    }\r\n    // If objGetPrototypeOf doesn't exist then just assume everything is ok.\r\n    return true;\r\n}\r\n/**\r\n * Gets the current prototype name using the ES6 name if available otherwise falling back to a use unknown as the name.\r\n * It's not critical for this to return a name, it's used to decorate the generated unique name for easier debugging only.\r\n * @param target\r\n * @param unknownValue\r\n * @ignore\r\n */\r\nfunction _getObjName(target, unknownValue) {\r\n    if (_hasOwnProperty(target, Prototype)) {\r\n        // Look like a prototype\r\n        return target.name || unknownValue || UnknownValue;\r\n    }\r\n    return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;\r\n}\r\n/**\r\n * Helper function when creating dynamic (inline) functions for classes, this helper performs the following tasks :-\r\n * - Saves references to all defined base class functions\r\n * - Calls the delegateFunc with the current target (this) and a base object reference that can be used to call all \"super\" functions.\r\n * - Will populate the class prototype for all overridden functions to support class extension that call the prototype instance.\r\n * Callers should use this helper when declaring all function within the constructor of a class, as mentioned above the delegateFunc is\r\n * passed both the target \"this\" and an object that can be used to call any base (super) functions, using this based object in place of\r\n * super.XXX() (which gets expanded to _super.prototype.XXX()) provides a better minification outcome and also ensures the correct \"this\"\r\n * context is maintained as TypeScript creates incorrect references using super.XXXX() for dynamically defined functions i.e. Functions\r\n * defined in the constructor or some other function (rather than declared as complete typescript functions).\r\n * ### Usage\r\n * ```typescript\r\n * import dynamicProto from \"@microsoft/dynamicproto-js\";\r\n * class ExampleClass extends BaseClass {\r\n *     constructor() {\r\n *         dynamicProto(ExampleClass, this, (_self, base) => {\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.newFunc = () => {\r\n *                 // Access any \"this\" instance property\r\n *                 if (_self.someProperty) {\r\n *                     ...\r\n *                 }\r\n *             }\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.myFunction = () => {\r\n *                 // Access any \"this\" instance property\r\n *                 if (_self.someProperty) {\r\n *                     // Call the base version of the function that we are overriding\r\n *                     base.myFunction();\r\n *                 }\r\n *                 ...\r\n *             }\r\n *             _self.initialize = () => {\r\n *                 ...\r\n *             }\r\n *             // Warnings: While the following will work as _self is simply a reference to\r\n *             // this, if anyone overrides myFunction() the overridden will be called first\r\n *             // as the normal JavaScript method resolution will occur and the defined\r\n *             // _self.initialize() function is actually gets removed from the instance and\r\n *             // a proxy prototype version is created to reference the created method.\r\n *             _self.initialize();\r\n *         });\r\n *     }\r\n * }\r\n * ```\r\n * @typeparam DPType This is the generic type of the class, used to keep intellisense valid\r\n * @typeparam DPCls The type that contains the prototype of the current class\r\n * @param theClass - This is the current class instance which contains the prototype for the current class\r\n * @param target - The current \"this\" (target) reference, when the class has been extended this.prototype will not be the 'theClass' value.\r\n * @param delegateFunc - The callback function (closure) that will create the dynamic function\r\n * @param options - Additional options to configure how the dynamic prototype operates\r\n */\r\nexport default function dynamicProto(theClass, target, delegateFunc, options) {\r\n    // Make sure that the passed theClass argument looks correct\r\n    if (!_hasOwnProperty(theClass, Prototype)) {\r\n        _throwTypeError(\"theClass is an invalid class definition.\");\r\n    }\r\n    // Quick check to make sure that the passed theClass argument looks correct (this is a common copy/paste error)\r\n    var classProto = theClass[Prototype];\r\n    if (!_checkPrototype(classProto, target)) {\r\n        _throwTypeError(\"[\" + _getObjName(theClass) + \"] not in hierarchy of [\" + _getObjName(target) + \"]\");\r\n    }\r\n    var className = null;\r\n    if (_hasOwnProperty(classProto, DynClassName)) {\r\n        // Only grab the class name if it's defined on this prototype (i.e. don't walk the prototype chain)\r\n        className = classProto[DynClassName];\r\n    }\r\n    else {\r\n        // As not all browser support name on the prototype creating a unique dynamic one if we have not already\r\n        // assigned one, so we can use a simple string as the lookup rather than an object for the dynamic instance\r\n        // function table lookup.\r\n        className = DynClassNamePrefix + _getObjName(theClass, \"_\") + \"$\" + _gblInst.n;\r\n        _gblInst.n++;\r\n        classProto[DynClassName] = className;\r\n    }\r\n    var perfOptions = dynamicProto[DynProtoDefaultOptions];\r\n    var useBaseInst = !!perfOptions[strUseBaseInst];\r\n    if (useBaseInst && options && options[strUseBaseInst] !== undefined) {\r\n        useBaseInst = !!options[strUseBaseInst];\r\n    }\r\n    // Get the current instance functions\r\n    var instFuncs = _getInstanceFuncs(target);\r\n    // Get all of the functions for any base instance (before they are potentially overridden)\r\n    var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);\r\n    // Execute the delegate passing in both the current target \"this\" and \"base\" function references\r\n    // Note casting the same type as we don't actually have the base class here and this will provide some intellisense support\r\n    delegateFunc(target, baseFuncs);\r\n    // Don't allow setting instance functions for older IE instances\r\n    var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];\r\n    if (setInstanceFunc && options) {\r\n        setInstanceFunc = !!options[strSetInstFuncs];\r\n    }\r\n    // Populate the Prototype for any overridden instance functions\r\n    _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);\r\n}\r\n/**\r\n * Exposes the default global options to allow global configuration, if the global values are disabled these will override\r\n * any passed values. This is primarily exposed to support unit-testing without the need for individual classes to expose\r\n * their internal usage of dynamic proto.\r\n */\r\ndynamicProto[DynProtoDefaultOptions] = _gblInst.o;\r\n//# sourceMappingURL=DynamicProto.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}