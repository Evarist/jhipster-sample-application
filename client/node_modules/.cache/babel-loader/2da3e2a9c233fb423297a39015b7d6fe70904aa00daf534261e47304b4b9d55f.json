{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 2.8.12\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { _DYN_CREATE_NEW, _DYN_DIAG_LOG, _DYN_GET_NEXT, _DYN_GET_PROCESS_TEL_CONT0, _DYN_INITIALIZE, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_SET_NEXT_PLUGIN, _DYN_TEARDOWN, _DYN_UPDATE, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\nimport { arrForEach, isArray, isFunction, isNullOrUndefined, proxyFunctionAs, setValue } from \"./HelperFuncs\";\nimport { STR_CORE, STR_EXTENSION_CONFIG, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\nimport { createProcessTelemetryContext, createProcessTelemetryUnloadContext, createProcessTelemetryUpdateContext } from \"./ProcessTelemetryContext\";\nimport { createUnloadHandlerContainer } from \"./UnloadHandlerContainer\";\nvar strGetPlugin = \"getPlugin\";\n/**\r\n * BaseTelemetryPlugin provides a basic implementation of the ITelemetryPlugin interface so that plugins\r\n * can avoid implementation the same set of boiler plate code as well as provide a base\r\n * implementation so that new default implementations can be added without breaking all plugins.\r\n */\nvar BaseTelemetryPlugin = /** @class */function () {\n  function BaseTelemetryPlugin() {\n    var _self = this; // Setting _self here as it's used outside of the dynamicProto as well\n    // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\n    var _isinitialized;\n    var _rootCtx; // Used as the root context, holding the current config and initialized core\n    var _nextPlugin; // Used for backward compatibility where plugins don't call the main pipeline\n    var _unloadHandlerContainer;\n    var _hooks;\n    _initDefaults();\n    dynamicProto(BaseTelemetryPlugin, _self, function (_self) {\n      _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {\n        _setDefaults(config, core, pluginChain);\n        _isinitialized = true;\n      };\n      _self[_DYN_TEARDOWN /* @min:%2eteardown */] = function (unloadCtx, unloadState) {\n        var _a;\n        // If this plugin has already been torn down (not operational) or is not initialized (core is not set)\n        // or the core being used for unload was not the same core used for initialization.\n        var core = _self[STR_CORE /* @min:%2ecore */];\n        if (!core || unloadCtx && core !== unloadCtx[STR_CORE /* @min:%2ecore */]()) {\n          // Do Nothing as either the plugin is not initialized or was not initialized by the current core\n          return;\n        }\n        var result;\n        var unloadDone = false;\n        var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);\n        var theUnloadState = unloadState || (_a = {\n          reason: 0 /* TelemetryUnloadReason.ManualTeardown */\n        }, _a[_DYN_IS_ASYNC /* @min:isAsync */] = false, _a);\n        function _unloadCallback() {\n          if (!unloadDone) {\n            unloadDone = true;\n            _unloadHandlerContainer.run(theUnloadCtx, unloadState);\n            var oldHooks = _hooks;\n            _hooks = [];\n            // Remove all instrumentation hooks\n            arrForEach(oldHooks, function (fn) {\n              fn.rm();\n            });\n            if (result === true) {\n              theUnloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](theUnloadState);\n            }\n            _initDefaults();\n          }\n        }\n        if (!_self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] || _self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {\n          _unloadCallback();\n        } else {\n          // Tell the caller that we will be calling processNext()\n          result = true;\n        }\n        return result;\n      };\n      _self[_DYN_UPDATE /* @min:%2eupdate */] = function (updateCtx, updateState) {\n        // If this plugin has already been torn down (not operational) or is not initialized (core is not set)\n        // or the core being used for unload was not the same core used for initialization.\n        var core = _self[STR_CORE /* @min:%2ecore */];\n        if (!core || updateCtx && core !== updateCtx[STR_CORE /* @min:%2ecore */]()) {\n          // Do Nothing\n          return;\n        }\n        var result;\n        var updateDone = false;\n        var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);\n        var theUpdateState = updateState || {\n          reason: 0 /* TelemetryUpdateReason.Unknown */\n        };\n\n        function _updateCallback() {\n          if (!updateDone) {\n            updateDone = true;\n            _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT /* @min:%2egetNext */]());\n          }\n        }\n\n        if (!_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {\n          _updateCallback();\n        } else {\n          result = true;\n        }\n        return result;\n      };\n      _self._addHook = function (hooks) {\n        if (hooks) {\n          if (isArray(hooks)) {\n            _hooks = _hooks.concat(hooks);\n          } else {\n            _hooks[_DYN_PUSH /* @min:%2epush */](hooks);\n          }\n        }\n      };\n      proxyFunctionAs(_self, \"_addUnloadCb\", function () {\n        return _unloadHandlerContainer;\n      }, \"add\");\n    });\n    // These are added after the dynamicProto so that are not moved to the prototype\n    _self[_DYN_DIAG_LOG /* @min:%2ediagLog */] = function (itemCtx) {\n      return _getTelCtx(itemCtx)[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\n    };\n\n    _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () {\n      return _isinitialized;\n    };\n    _self.setInitialized = function (isInitialized) {\n      _isinitialized = isInitialized;\n    };\n    // _self.getNextPlugin = () => DO NOT IMPLEMENT\n    // Sub-classes of this base class *should* not be relying on this value and instead\n    // should use processNext() function. If you require access to the plugin use the\n    // IProcessTelemetryContext.getNext().getPlugin() while in the pipeline, Note getNext() may return null.\n    _self[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] = function (next) {\n      _nextPlugin = next;\n    };\n    _self[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = function (env, itemCtx) {\n      if (itemCtx) {\n        // Normal core execution sequence\n        itemCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);\n      } else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\n        // Looks like backward compatibility or out of band processing. And as it looks\n        // like a ITelemetryPlugin or ITelemetryPluginChain, just call processTelemetry\n        _nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, null);\n      }\n    };\n    _self._getTelCtx = _getTelCtx;\n    function _getTelCtx(currentCtx) {\n      if (currentCtx === void 0) {\n        currentCtx = null;\n      }\n      var itemCtx = currentCtx;\n      if (!itemCtx) {\n        var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE /* @min:%2ecore */]);\n        // tslint:disable-next-line: prefer-conditional-expression\n        if (_nextPlugin && _nextPlugin[strGetPlugin]) {\n          // Looks like a chain object\n          itemCtx = rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin[strGetPlugin]);\n        } else {\n          itemCtx = rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin);\n        }\n      }\n      return itemCtx;\n    }\n    function _setDefaults(config, core, pluginChain) {\n      if (config) {\n        // Make sure the extensionConfig exists\n        setValue(config, STR_EXTENSION_CONFIG, [], null, isNullOrUndefined);\n      }\n      if (!pluginChain && core) {\n        // Get the first plugin from the core\n        pluginChain = core[_DYN_GET_PROCESS_TEL_CONT0 /* @min:%2egetProcessTelContext */]()[_DYN_GET_NEXT /* @min:%2egetNext */]();\n      }\n\n      var nextPlugin = _nextPlugin;\n      if (_nextPlugin && _nextPlugin[strGetPlugin]) {\n        // If it looks like a proxy/chain then get the plugin\n        nextPlugin = _nextPlugin[strGetPlugin]();\n      }\n      // Support legacy plugins where core was defined as a property\n      _self[STR_CORE /* @min:%2ecore */] = core;\n      _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);\n    }\n    function _initDefaults() {\n      _isinitialized = false;\n      _self[STR_CORE /* @min:%2ecore */] = null;\n      _rootCtx = null;\n      _nextPlugin = null;\n      _hooks = [];\n      _unloadHandlerContainer = createUnloadHandlerContainer();\n    }\n  }\n  // Removed Stub for BaseTelemetryPlugin.prototype.initialize.\n  // Removed Stub for BaseTelemetryPlugin.prototype.teardown.\n  // Removed Stub for BaseTelemetryPlugin.prototype.update.\n  // Removed Stub for BaseTelemetryPlugin.prototype._addUnloadCb.\n  // Removed Stub for BaseTelemetryPlugin.prototype._addHook.\n  // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  // this will be removed when ES3 support is dropped.\n  BaseTelemetryPlugin.__ieDyn = 1;\n  return BaseTelemetryPlugin;\n}();\nexport { BaseTelemetryPlugin };","map":{"version":3,"names":["dynamicProto","_DYN_CREATE_NEW","_DYN_DIAG_LOG","_DYN_GET_NEXT","_DYN_GET_PROCESS_TEL_CONT0","_DYN_INITIALIZE","_DYN_IS_ASYNC","_DYN_IS_INITIALIZED","_DYN_PROCESS_NEXT","_DYN_PUSH","_DYN_SET_NEXT_PLUGIN","_DYN_TEARDOWN","_DYN_UPDATE","_DYN__DO_TEARDOWN","arrForEach","isArray","isFunction","isNullOrUndefined","proxyFunctionAs","setValue","STR_CORE","STR_EXTENSION_CONFIG","STR_PROCESS_TELEMETRY","createProcessTelemetryContext","createProcessTelemetryUnloadContext","createProcessTelemetryUpdateContext","createUnloadHandlerContainer","strGetPlugin","BaseTelemetryPlugin","_self","_isinitialized","_rootCtx","_nextPlugin","_unloadHandlerContainer","_hooks","_initDefaults","config","core","extensions","pluginChain","_setDefaults","unloadCtx","unloadState","_a","result","unloadDone","theUnloadCtx","theUnloadState","reason","_unloadCallback","run","oldHooks","fn","rm","updateCtx","updateState","updateDone","theUpdateCtx","theUpdateState","_updateCallback","getCfg","_doUpdate","_addHook","hooks","concat","itemCtx","_getTelCtx","setInitialized","isInitialized","next","env","currentCtx","rootCtx","nextPlugin"],"sources":["/Users/evaristlobo/Documents/GitHub/jhipster-sample-application/client/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/BaseTelemetryPlugin.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { _DYN_CREATE_NEW, _DYN_DIAG_LOG, _DYN_GET_NEXT, _DYN_GET_PROCESS_TEL_CONT0, _DYN_INITIALIZE, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_SET_NEXT_PLUGIN, _DYN_TEARDOWN, _DYN_UPDATE, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\r\nimport { arrForEach, isArray, isFunction, isNullOrUndefined, proxyFunctionAs, setValue } from \"./HelperFuncs\";\r\nimport { STR_CORE, STR_EXTENSION_CONFIG, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\r\nimport { createProcessTelemetryContext, createProcessTelemetryUnloadContext, createProcessTelemetryUpdateContext } from \"./ProcessTelemetryContext\";\r\nimport { createUnloadHandlerContainer } from \"./UnloadHandlerContainer\";\r\nvar strGetPlugin = \"getPlugin\";\r\n/**\r\n * BaseTelemetryPlugin provides a basic implementation of the ITelemetryPlugin interface so that plugins\r\n * can avoid implementation the same set of boiler plate code as well as provide a base\r\n * implementation so that new default implementations can be added without breaking all plugins.\r\n */\r\nvar BaseTelemetryPlugin = /** @class */ (function () {\r\n    function BaseTelemetryPlugin() {\r\n        var _self = this; // Setting _self here as it's used outside of the dynamicProto as well\r\n        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\r\n        var _isinitialized;\r\n        var _rootCtx; // Used as the root context, holding the current config and initialized core\r\n        var _nextPlugin; // Used for backward compatibility where plugins don't call the main pipeline\r\n        var _unloadHandlerContainer;\r\n        var _hooks;\r\n        _initDefaults();\r\n        dynamicProto(BaseTelemetryPlugin, _self, function (_self) {\r\n            _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {\r\n                _setDefaults(config, core, pluginChain);\r\n                _isinitialized = true;\r\n            };\r\n            _self[_DYN_TEARDOWN /* @min:%2eteardown */] = function (unloadCtx, unloadState) {\r\n                var _a;\r\n                // If this plugin has already been torn down (not operational) or is not initialized (core is not set)\r\n                // or the core being used for unload was not the same core used for initialization.\r\n                var core = _self[STR_CORE /* @min:%2ecore */];\r\n                if (!core || (unloadCtx && core !== unloadCtx[STR_CORE /* @min:%2ecore */]())) {\r\n                    // Do Nothing as either the plugin is not initialized or was not initialized by the current core\r\n                    return;\r\n                }\r\n                var result;\r\n                var unloadDone = false;\r\n                var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);\r\n                var theUnloadState = unloadState || (_a = {\r\n                        reason: 0 /* TelemetryUnloadReason.ManualTeardown */\r\n                    },\r\n                    _a[_DYN_IS_ASYNC /* @min:isAsync */] = false,\r\n                    _a);\r\n                function _unloadCallback() {\r\n                    if (!unloadDone) {\r\n                        unloadDone = true;\r\n                        _unloadHandlerContainer.run(theUnloadCtx, unloadState);\r\n                        var oldHooks = _hooks;\r\n                        _hooks = [];\r\n                        // Remove all instrumentation hooks\r\n                        arrForEach(oldHooks, function (fn) {\r\n                            fn.rm();\r\n                        });\r\n                        if (result === true) {\r\n                            theUnloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](theUnloadState);\r\n                        }\r\n                        _initDefaults();\r\n                    }\r\n                }\r\n                if (!_self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] || _self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {\r\n                    _unloadCallback();\r\n                }\r\n                else {\r\n                    // Tell the caller that we will be calling processNext()\r\n                    result = true;\r\n                }\r\n                return result;\r\n            };\r\n            _self[_DYN_UPDATE /* @min:%2eupdate */] = function (updateCtx, updateState) {\r\n                // If this plugin has already been torn down (not operational) or is not initialized (core is not set)\r\n                // or the core being used for unload was not the same core used for initialization.\r\n                var core = _self[STR_CORE /* @min:%2ecore */];\r\n                if (!core || (updateCtx && core !== updateCtx[STR_CORE /* @min:%2ecore */]())) {\r\n                    // Do Nothing\r\n                    return;\r\n                }\r\n                var result;\r\n                var updateDone = false;\r\n                var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);\r\n                var theUpdateState = updateState || {\r\n                    reason: 0 /* TelemetryUpdateReason.Unknown */\r\n                };\r\n                function _updateCallback() {\r\n                    if (!updateDone) {\r\n                        updateDone = true;\r\n                        _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT /* @min:%2egetNext */]());\r\n                    }\r\n                }\r\n                if (!_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {\r\n                    _updateCallback();\r\n                }\r\n                else {\r\n                    result = true;\r\n                }\r\n                return result;\r\n            };\r\n            _self._addHook = function (hooks) {\r\n                if (hooks) {\r\n                    if (isArray(hooks)) {\r\n                        _hooks = _hooks.concat(hooks);\r\n                    }\r\n                    else {\r\n                        _hooks[_DYN_PUSH /* @min:%2epush */](hooks);\r\n                    }\r\n                }\r\n            };\r\n            proxyFunctionAs(_self, \"_addUnloadCb\", function () { return _unloadHandlerContainer; }, \"add\");\r\n        });\r\n        // These are added after the dynamicProto so that are not moved to the prototype\r\n        _self[_DYN_DIAG_LOG /* @min:%2ediagLog */] = function (itemCtx) {\r\n            return _getTelCtx(itemCtx)[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\r\n        };\r\n        _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () {\r\n            return _isinitialized;\r\n        };\r\n        _self.setInitialized = function (isInitialized) {\r\n            _isinitialized = isInitialized;\r\n        };\r\n        // _self.getNextPlugin = () => DO NOT IMPLEMENT\r\n        // Sub-classes of this base class *should* not be relying on this value and instead\r\n        // should use processNext() function. If you require access to the plugin use the\r\n        // IProcessTelemetryContext.getNext().getPlugin() while in the pipeline, Note getNext() may return null.\r\n        _self[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] = function (next) {\r\n            _nextPlugin = next;\r\n        };\r\n        _self[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = function (env, itemCtx) {\r\n            if (itemCtx) {\r\n                // Normal core execution sequence\r\n                itemCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);\r\n            }\r\n            else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\r\n                // Looks like backward compatibility or out of band processing. And as it looks\r\n                // like a ITelemetryPlugin or ITelemetryPluginChain, just call processTelemetry\r\n                _nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, null);\r\n            }\r\n        };\r\n        _self._getTelCtx = _getTelCtx;\r\n        function _getTelCtx(currentCtx) {\r\n            if (currentCtx === void 0) { currentCtx = null; }\r\n            var itemCtx = currentCtx;\r\n            if (!itemCtx) {\r\n                var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE /* @min:%2ecore */]);\r\n                // tslint:disable-next-line: prefer-conditional-expression\r\n                if (_nextPlugin && _nextPlugin[strGetPlugin]) {\r\n                    // Looks like a chain object\r\n                    itemCtx = rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin[strGetPlugin]);\r\n                }\r\n                else {\r\n                    itemCtx = rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin);\r\n                }\r\n            }\r\n            return itemCtx;\r\n        }\r\n        function _setDefaults(config, core, pluginChain) {\r\n            if (config) {\r\n                // Make sure the extensionConfig exists\r\n                setValue(config, STR_EXTENSION_CONFIG, [], null, isNullOrUndefined);\r\n            }\r\n            if (!pluginChain && core) {\r\n                // Get the first plugin from the core\r\n                pluginChain = core[_DYN_GET_PROCESS_TEL_CONT0 /* @min:%2egetProcessTelContext */]()[_DYN_GET_NEXT /* @min:%2egetNext */]();\r\n            }\r\n            var nextPlugin = _nextPlugin;\r\n            if (_nextPlugin && _nextPlugin[strGetPlugin]) {\r\n                // If it looks like a proxy/chain then get the plugin\r\n                nextPlugin = _nextPlugin[strGetPlugin]();\r\n            }\r\n            // Support legacy plugins where core was defined as a property\r\n            _self[STR_CORE /* @min:%2ecore */] = core;\r\n            _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);\r\n        }\r\n        function _initDefaults() {\r\n            _isinitialized = false;\r\n            _self[STR_CORE /* @min:%2ecore */] = null;\r\n            _rootCtx = null;\r\n            _nextPlugin = null;\r\n            _hooks = [];\r\n            _unloadHandlerContainer = createUnloadHandlerContainer();\r\n        }\r\n    }\r\n    BaseTelemetryPlugin.prototype.initialize = function (config, core, extensions, pluginChain) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Tear down the plugin and remove any hooked value, the plugin should be removed so that it is no longer initialized and\r\n     * therefore could be re-initialized after being torn down. The plugin should ensure that once this has been called any further\r\n     * processTelemetry calls are ignored and it just calls the processNext() with the provided context.\r\n     * @param unloadCtx - This is the context that should be used during unloading.\r\n     * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.\r\n     * @returns boolean - true if the plugin has or will call processNext(), this for backward compatibility as previously teardown was synchronous and returned nothing.\r\n     */\r\n    BaseTelemetryPlugin.prototype.teardown = function (unloadCtx, unloadState) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return false;\r\n    };\r\n    /**\r\n     * The the plugin should re-evaluate configuration and update any cached configuration settings.\r\n     * @param updateCtx - This is the context that should be used during updating.\r\n     * @param updateState - The details / state of the update process, it holds details like the current and previous configuration.\r\n     * @returns boolean - true if the plugin has or will call updateCtx.processNext(), this allows the plugin to perform any asynchronous operations.\r\n     */\r\n    BaseTelemetryPlugin.prototype.update = function (updateCtx, updateState) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Add an unload handler that will be called when the SDK is being unloaded\r\n     * @param handler - the handler\r\n     */\r\n    BaseTelemetryPlugin.prototype._addUnloadCb = function (handler) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Add this hook so that it is automatically removed during unloading\r\n     * @param hooks - The single hook or an array of IInstrumentHook objects\r\n     */\r\n    BaseTelemetryPlugin.prototype._addHook = function (hooks) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return BaseTelemetryPlugin;\r\n}());\r\nexport { BaseTelemetryPlugin };\r\n//# sourceMappingURL=BaseTelemetryPlugin.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}