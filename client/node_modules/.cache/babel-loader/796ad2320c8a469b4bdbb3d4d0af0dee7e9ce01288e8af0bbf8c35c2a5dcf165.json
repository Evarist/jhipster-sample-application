{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 2.8.12\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nimport { __spreadArrayFn as __spreadArray } from \"@microsoft/applicationinsights-shims\";\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { objCreateFn } from \"@microsoft/applicationinsights-shims\";\nimport { _DYN_ADD_NOTIFICATION_LIS1, _DYN_CONFIG, _DYN_FLUSH, _DYN_GET_NOTIFY_MGR, _DYN_GET_PLUGIN, _DYN_GET_PROCESS_TEL_CONT0, _DYN_IDENTIFIER, _DYN_INITIALIZE, _DYN_INSTRUMENTATION_KEY, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_LOGGER, _DYN_MESSAGE, _DYN_MESSAGE_ID, _DYN_NAME, _DYN_ON_COMPLETE, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_REMOVE_NOTIFICATION_2, _DYN_SET_ENABLED, _DYN_SPLICE, _DYN_STOP_POLLING_INTERNA3, _DYN_TEARDOWN, _DYN_TIME, _DYN__EXTENSIONS } from \"../__DynamicConstants\";\nimport { ChannelControllerPriority, createChannelControllerPlugin, createChannelQueues } from \"./ChannelController\";\nimport { createCookieMgr } from \"./CookieMgr\";\nimport { createUniqueNamespace } from \"./DataCacheHelper\";\nimport { getDebugListener } from \"./DbgExtensionUtils\";\nimport { DiagnosticLogger, _InternalLogMessage, _throwInternal, _warnToConsole } from \"./DiagnosticLogger\";\nimport { arrForEach, arrIndexOf, getCfgValue, getSetValue, isFunction, isNullOrUndefined, objExtend, objFreeze, proxyFunctionAs, proxyFunctions, throwError, toISOString } from \"./HelperFuncs\";\nimport { STR_CHANNELS, STR_CORE, STR_CREATE_PERF_MGR, STR_DISABLED, STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_EVENTS_SENT, STR_EXTENSIONS, STR_EXTENSION_CONFIG, STR_GET_PERF_MGR, STR_PRIORITY } from \"./InternalConstants\";\nimport { PerfManager, getGblPerfMgr } from \"./PerfManager\";\nimport { createProcessTelemetryContext, createProcessTelemetryUnloadContext, createProcessTelemetryUpdateContext, createTelemetryProxyChain } from \"./ProcessTelemetryContext\";\nimport { _getPluginState, createDistributedTraceContext, initializePlugins, sortPlugins } from \"./TelemetryHelpers\";\nimport { TelemetryInitializerPlugin } from \"./TelemetryInitializerPlugin\";\nimport { createUnloadHandlerContainer } from \"./UnloadHandlerContainer\";\nvar strValidationError = \"Plugins must provide initialize method\";\nvar strNotificationManager = \"_notificationManager\";\nvar strSdkUnloadingError = \"SDK is still unloading...\";\nvar strSdkNotInitialized = \"SDK is not initialized\";\n// const strPluginUnloadFailed = \"Failed to unload plugin\";\nvar defaultInitConfig = {\n  // Have the Diagnostic Logger default to log critical errors to the console\n  loggingLevelConsole: 1 /* eLoggingSeverity.CRITICAL */\n};\n/**\r\n * Helper to create the default performance manager\r\n * @param core\r\n * @param notificationMgr\r\n */\nfunction _createPerfManager(core, notificationMgr) {\n  return new PerfManager(notificationMgr);\n}\nfunction _validateExtensions(logger, channelPriority, allExtensions) {\n  var _a;\n  // Concat all available extensions\n  var coreExtensions = [];\n  // Check if any two extensions have the same priority, then warn to console\n  // And extract the local extensions from the\n  var extPriorities = {};\n  // Extension validation\n  arrForEach(allExtensions, function (ext) {\n    // Check for ext.initialize\n    if (isNullOrUndefined(ext) || isNullOrUndefined(ext[_DYN_INITIALIZE /* @min:%2einitialize */])) {\n      throwError(strValidationError);\n    }\n    var extPriority = ext[STR_PRIORITY /* @min:%2epriority */];\n    var identifier = ext[_DYN_IDENTIFIER /* @min:%2eidentifier */];\n    if (ext && extPriority) {\n      if (!isNullOrUndefined(extPriorities[extPriority])) {\n        _warnToConsole(logger, \"Two extensions have same priority #\" + extPriority + \" - \" + extPriorities[extPriority] + \", \" + identifier);\n      } else {\n        // set a value\n        extPriorities[extPriority] = identifier;\n      }\n    }\n    // Split extensions to core and channelController\n    if (!extPriority || extPriority < channelPriority) {\n      // Add to core extension that will be managed by BaseCore\n      coreExtensions[_DYN_PUSH /* @min:%2epush */](ext);\n    }\n  });\n  return _a = {\n    all: allExtensions\n  }, _a[STR_CORE /* @min:core */] = coreExtensions, _a;\n}\nfunction _isPluginPresent(thePlugin, plugins) {\n  var exists = false;\n  arrForEach(plugins, function (plugin) {\n    if (plugin === thePlugin) {\n      exists = true;\n      return -1;\n    }\n  });\n  return exists;\n}\nfunction _createDummyNotificationManager() {\n  var _a;\n  return objCreateFn((_a = {}, _a[_DYN_ADD_NOTIFICATION_LIS1 /* @min:addNotificationListener */] = function (listener) {}, _a[_DYN_REMOVE_NOTIFICATION_2 /* @min:removeNotificationListener */] = function (listener) {}, _a[STR_EVENTS_SENT /* @min:eventsSent */] = function (events) {}, _a[STR_EVENTS_DISCARDED /* @min:eventsDiscarded */] = function (events, reason) {}, _a[STR_EVENTS_SEND_REQUEST /* @min:eventsSendRequest */] = function (sendReason, isAsync) {}, _a));\n}\nvar BaseCore = /** @class */function () {\n  function BaseCore() {\n    // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\n    var _config;\n    var _isInitialized;\n    var _eventQueue;\n    var _notificationManager;\n    var _perfManager;\n    var _cfgPerfManager;\n    var _cookieManager;\n    var _pluginChain;\n    var _configExtensions;\n    var _coreExtensions;\n    var _channelControl;\n    var _channelConfig;\n    var _channelQueue;\n    var _isUnloading;\n    var _telemetryInitializerPlugin;\n    var _internalLogsEventName;\n    var _evtNamespace;\n    var _unloadHandlers;\n    var _debugListener;\n    var _traceCtx;\n    /**\r\n     * Internal log poller\r\n     */\n    var _internalLogPoller = 0;\n    dynamicProto(BaseCore, this, function (_self) {\n      // Set the default values (also called during teardown)\n      _initDefaults();\n      _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () {\n        return _isInitialized;\n      };\n      // Creating the self.initialize = ()\n      _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, extensions, logger, notificationManager) {\n        if (_isUnloading) {\n          throwError(strSdkUnloadingError);\n        }\n        // Make sure core is only initialized once\n        if (_self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {\n          throwError(\"Core should not be initialized more than once\");\n        }\n        _config = config || {};\n        _self[_DYN_CONFIG /* @min:%2econfig */] = _config;\n        if (isNullOrUndefined(config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */])) {\n          throwError(\"Please provide instrumentation key\");\n        }\n        _notificationManager = notificationManager;\n        // For backward compatibility only\n        _self[strNotificationManager] = notificationManager;\n        _initDebugListener();\n        _initPerfManager();\n        // add notification to the extensions in the config so other plugins can access it\n        _initExtConfig();\n        if (logger) {\n          _self[_DYN_LOGGER /* @min:%2elogger */] = logger;\n        }\n        var cfgExtensions = getSetValue(_config, STR_EXTENSIONS, []);\n        // Extension validation\n        _configExtensions = [];\n        _configExtensions[_DYN_PUSH /* @min:%2epush */].apply(_configExtensions, __spreadArray(__spreadArray([], extensions, false), cfgExtensions, false));\n        _channelConfig = getSetValue(_config, STR_CHANNELS, []);\n        _initPluginChain(null);\n        if (!_channelQueue || _channelQueue[_DYN_LENGTH /* @min:%2elength */] === 0) {\n          throwError(\"No \" + STR_CHANNELS + \" available\");\n        }\n        _isInitialized = true;\n        _self.releaseQueue();\n      };\n      _self.getTransmissionControls = function () {\n        var controls = [];\n        if (_channelQueue) {\n          arrForEach(_channelQueue, function (channels) {\n            controls[_DYN_PUSH /* @min:%2epush */](channels.queue);\n          });\n        }\n        return objFreeze(controls);\n      };\n      _self.track = function (telemetryItem) {\n        // setup default iKey if not passed in\n        telemetryItem.iKey = telemetryItem.iKey || _config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];\n        // add default timestamp if not passed in\n        telemetryItem[_DYN_TIME /* @min:%2etime */] = telemetryItem[_DYN_TIME /* @min:%2etime */] || toISOString(new Date());\n        // Common Schema 4.0\n        telemetryItem.ver = telemetryItem.ver || \"4.0\";\n        if (!_isUnloading && _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {\n          // Process the telemetry plugin chain\n          _createTelCtx()[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](telemetryItem);\n        } else {\n          // Queue events until all extensions are initialized\n          _eventQueue[_DYN_PUSH /* @min:%2epush */](telemetryItem);\n        }\n      };\n      _self[_DYN_GET_PROCESS_TEL_CONT0 /* @min:%2egetProcessTelContext */] = _createTelCtx;\n      _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */] = function () {\n        if (!_notificationManager) {\n          // Create Dummy notification manager\n          _notificationManager = _createDummyNotificationManager();\n          // For backward compatibility only\n          _self[strNotificationManager] = _notificationManager;\n        }\n        return _notificationManager;\n      };\n      /**\r\n       * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.\r\n       * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be\r\n       * called.\r\n       * @param {INotificationListener} listener - An INotificationListener object.\r\n       */\n      _self[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {\n        if (_notificationManager) {\n          _notificationManager[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](listener);\n        }\n      };\n      /**\r\n       * Removes all instances of the listener.\r\n       * @param {INotificationListener} listener - INotificationListener to remove.\r\n       */\n      _self[_DYN_REMOVE_NOTIFICATION_2 /* @min:%2eremoveNotificationListener */] = function (listener) {\n        if (_notificationManager) {\n          _notificationManager[_DYN_REMOVE_NOTIFICATION_2 /* @min:%2eremoveNotificationListener */](listener);\n        }\n      };\n      _self.getCookieMgr = function () {\n        if (!_cookieManager) {\n          _cookieManager = createCookieMgr(_config, _self[_DYN_LOGGER /* @min:%2elogger */]);\n        }\n\n        return _cookieManager;\n      };\n      _self.setCookieMgr = function (cookieMgr) {\n        _cookieManager = cookieMgr;\n      };\n      _self[STR_GET_PERF_MGR /* @min:%2egetPerfMgr */] = function () {\n        if (!_perfManager && !_cfgPerfManager) {\n          if (getCfgValue(_config.enablePerfMgr)) {\n            var createPerfMgr = getCfgValue(_config[STR_CREATE_PERF_MGR /* @min:%2ecreatePerfMgr */]);\n            if (isFunction(createPerfMgr)) {\n              _cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]());\n            }\n          }\n        }\n\n        return _perfManager || _cfgPerfManager || getGblPerfMgr();\n      };\n      _self.setPerfMgr = function (perfMgr) {\n        _perfManager = perfMgr;\n      };\n      _self.eventCnt = function () {\n        return _eventQueue[_DYN_LENGTH /* @min:%2elength */];\n      };\n\n      _self.releaseQueue = function () {\n        if (_isInitialized && _eventQueue[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          var eventQueue = _eventQueue;\n          _eventQueue = [];\n          arrForEach(eventQueue, function (event) {\n            _createTelCtx()[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](event);\n          });\n        }\n      };\n      /**\r\n       * Periodically check logger.queue for log messages to be flushed\r\n       */\n      _self.pollInternalLogs = function (eventName) {\n        _internalLogsEventName = eventName || null;\n        var interval = getCfgValue(_config.diagnosticLogInterval);\n        if (!interval || !(interval > 0)) {\n          interval = 10000;\n        }\n        if (_internalLogPoller) {\n          clearInterval(_internalLogPoller);\n        }\n        _internalLogPoller = setInterval(function () {\n          _flushInternalLogs();\n        }, interval);\n        return _internalLogPoller;\n      };\n      /**\r\n       * Stop polling log messages from logger.queue\r\n       */\n      _self[_DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */] = function () {\n        if (_internalLogPoller) {\n          clearInterval(_internalLogPoller);\n          _internalLogPoller = 0;\n          _flushInternalLogs();\n        }\n      };\n      // Add addTelemetryInitializer\n      proxyFunctions(_self, function () {\n        return _telemetryInitializerPlugin;\n      }, [\"addTelemetryInitializer\"]);\n      _self.unload = function (isAsync, unloadComplete, cbTimeout) {\n        var _a;\n        if (isAsync === void 0) {\n          isAsync = true;\n        }\n        if (!_isInitialized) {\n          // The SDK is not initialized\n          throwError(strSdkNotInitialized);\n        }\n        // Check if the SDK still unloading so throw\n        if (_isUnloading) {\n          // The SDK is already unloading\n          throwError(strSdkUnloadingError);\n        }\n        var unloadState = (_a = {\n          reason: 50 /* TelemetryUnloadReason.SdkUnload */\n        }, _a[_DYN_IS_ASYNC /* @min:isAsync */] = isAsync, _a.flushComplete = false, _a);\n        var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);\n        processUnloadCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {\n          _initDefaults();\n          unloadComplete && unloadComplete(unloadState);\n        }, _self);\n        function _doUnload(flushComplete) {\n          unloadState.flushComplete = flushComplete;\n          _isUnloading = true;\n          // Run all of the unload handlers first (before unloading the plugins)\n          _unloadHandlers.run(processUnloadCtx, unloadState);\n          // Stop polling the internal logs\n          _self[_DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */]();\n          // Start unloading the components, from this point onwards the SDK should be considered to be in an unstable state\n          processUnloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\n        }\n        if (!_flushChannels(isAsync, _doUnload, 6 /* SendRequestReason.SdkUnload */, cbTimeout)) {\n          _doUnload(false);\n        }\n      };\n      _self[_DYN_GET_PLUGIN /* @min:%2egetPlugin */] = _getPlugin;\n      _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {\n        if (!plugin) {\n          addCb && addCb(false);\n          _logOrThrowError(strValidationError);\n          return;\n        }\n        var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */]);\n        if (existingPlugin && !replaceExisting) {\n          addCb && addCb(false);\n          _logOrThrowError(\"Plugin [\" + plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"] is already loaded!\");\n          return;\n        }\n        var updateState = {\n          reason: 16 /* TelemetryUpdateReason.PluginAdded */\n        };\n\n        function _addPlugin(removed) {\n          _configExtensions[_DYN_PUSH /* @min:%2epush */](plugin);\n          updateState.added = [plugin];\n          // Re-Initialize the plugin chain\n          _initPluginChain(updateState);\n          addCb && addCb(true);\n        }\n        if (existingPlugin) {\n          var removedPlugins_1 = [existingPlugin.plugin];\n          var unloadState = {\n            reason: 2 /* TelemetryUnloadReason.PluginReplace */,\n            isAsync: !!isAsync\n          };\n          _removePlugins(removedPlugins_1, unloadState, function (removed) {\n            if (!removed) {\n              // Previous plugin was successfully removed or was not installed\n              addCb && addCb(false);\n            } else {\n              updateState.removed = removedPlugins_1;\n              updateState.reason |= 32 /* TelemetryUpdateReason.PluginRemoved */;\n              _addPlugin(true);\n            }\n          });\n        } else {\n          _addPlugin(false);\n        }\n      };\n      _self.evtNamespace = function () {\n        return _evtNamespace;\n      };\n      _self[_DYN_FLUSH /* @min:%2eflush */] = _flushChannels;\n      _self.getTraceCtx = function (createNew) {\n        if (!_traceCtx) {\n          _traceCtx = createDistributedTraceContext();\n        }\n        return _traceCtx;\n      };\n      _self.setTraceCtx = function (traceCtx) {\n        _traceCtx = traceCtx || null;\n      };\n      // Create the addUnloadCb\n      proxyFunctionAs(_self, \"addUnloadCb\", function () {\n        return _unloadHandlers;\n      }, \"add\");\n      function _initDefaults() {\n        _isInitialized = false;\n        // Use a default logger so initialization errors are not dropped on the floor with full logging\n        _config = objExtend(true, {}, defaultInitConfig);\n        _self[_DYN_CONFIG /* @min:%2econfig */] = _config;\n        _self[_DYN_LOGGER /* @min:%2elogger */] = new DiagnosticLogger(_config);\n        _self[_DYN__EXTENSIONS /* @min:%2e_extensions */] = [];\n        _telemetryInitializerPlugin = new TelemetryInitializerPlugin();\n        _eventQueue = [];\n        _notificationManager = null;\n        _perfManager = null;\n        _cfgPerfManager = null;\n        _cookieManager = null;\n        _pluginChain = null;\n        _coreExtensions = null;\n        _configExtensions = [];\n        _channelControl = null;\n        _channelConfig = null;\n        _channelQueue = null;\n        _isUnloading = false;\n        _internalLogsEventName = null;\n        _evtNamespace = createUniqueNamespace(\"AIBaseCore\", true);\n        _unloadHandlers = createUnloadHandlerContainer();\n        _traceCtx = null;\n      }\n      function _createTelCtx() {\n        return createProcessTelemetryContext(_getPluginChain(), _config, _self);\n      }\n      // Initialize or Re-initialize the plugins\n      function _initPluginChain(updateState) {\n        // Extension validation\n        var theExtensions = _validateExtensions(_self[_DYN_LOGGER /* @min:%2elogger */], ChannelControllerPriority, _configExtensions);\n        _coreExtensions = theExtensions[STR_CORE /* @min:%2ecore */];\n        _pluginChain = null;\n        // Sort the complete set of extensions by priority\n        var allExtensions = theExtensions.all;\n        // Initialize the Channel Queues and the channel plugins first\n        _channelQueue = objFreeze(createChannelQueues(_channelConfig, allExtensions, _self));\n        if (_channelControl) {\n          // During add / remove of a plugin this may get called again, so don't re-add if already present\n          // But we also want the controller as the last, so remove if already present\n          // And reusing the existing instance, just in case an installed plugin has a reference and\n          // is using it.\n          var idx = arrIndexOf(allExtensions, _channelControl);\n          if (idx !== -1) {\n            allExtensions[_DYN_SPLICE /* @min:%2esplice */](idx, 1);\n          }\n          idx = arrIndexOf(_coreExtensions, _channelControl);\n          if (idx !== -1) {\n            _coreExtensions[_DYN_SPLICE /* @min:%2esplice */](idx, 1);\n          }\n          _channelControl._setQueue(_channelQueue);\n        } else {\n          _channelControl = createChannelControllerPlugin(_channelQueue, _self);\n        }\n        // Add on \"channelController\" as the last \"plugin\"\n        allExtensions[_DYN_PUSH /* @min:%2epush */](_channelControl);\n        _coreExtensions[_DYN_PUSH /* @min:%2epush */](_channelControl);\n        // Required to allow plugins to call core.getPlugin() during their own initialization\n        _self[_DYN__EXTENSIONS /* @min:%2e_extensions */] = sortPlugins(allExtensions);\n        // Initialize the controls\n        _channelControl[_DYN_INITIALIZE /* @min:%2einitialize */](_config, _self, allExtensions);\n        initializePlugins(_createTelCtx(), allExtensions);\n        // Now reset the extensions to just those being managed by Basecore\n        _self[_DYN__EXTENSIONS /* @min:%2e_extensions */] = objFreeze(sortPlugins(_coreExtensions || [])).slice();\n        if (updateState) {\n          _doUpdate(updateState);\n        }\n      }\n      function _getPlugin(pluginIdentifier) {\n        var _a;\n        var theExt = null;\n        var thePlugin = null;\n        arrForEach(_self[_DYN__EXTENSIONS /* @min:%2e_extensions */], function (ext) {\n          if (ext[_DYN_IDENTIFIER /* @min:%2eidentifier */] === pluginIdentifier && ext !== _channelControl && ext !== _telemetryInitializerPlugin) {\n            thePlugin = ext;\n            return -1;\n          }\n        });\n        if (!thePlugin && _channelControl) {\n          // Check the channel Controller\n          thePlugin = _channelControl.getChannel(pluginIdentifier);\n        }\n        if (thePlugin) {\n          theExt = (_a = {\n            plugin: thePlugin\n          }, _a[_DYN_SET_ENABLED /* @min:setEnabled */] = function (enabled) {\n            _getPluginState(thePlugin)[STR_DISABLED] = !enabled;\n          }, _a.isEnabled = function () {\n            var pluginState = _getPluginState(thePlugin);\n            return !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] && !pluginState[STR_DISABLED];\n          }, _a.remove = function (isAsync, removeCb) {\n            var _a;\n            if (isAsync === void 0) {\n              isAsync = true;\n            }\n            var pluginsToRemove = [thePlugin];\n            var unloadState = (_a = {\n              reason: 1 /* TelemetryUnloadReason.PluginUnload */\n            }, _a[_DYN_IS_ASYNC /* @min:isAsync */] = isAsync, _a);\n            _removePlugins(pluginsToRemove, unloadState, function (removed) {\n              if (removed) {\n                // Re-Initialize the plugin chain\n                _initPluginChain({\n                  reason: 32 /* TelemetryUpdateReason.PluginRemoved */,\n                  removed: pluginsToRemove\n                });\n              }\n              removeCb && removeCb(removed);\n            });\n          }, _a);\n        }\n        return theExt;\n      }\n      function _getPluginChain() {\n        if (!_pluginChain) {\n          // copy the collection of extensions\n          var extensions = (_coreExtensions || []).slice();\n          // During add / remove this may get called again, so don't readd if already present\n          if (arrIndexOf(extensions, _telemetryInitializerPlugin) === -1) {\n            extensions[_DYN_PUSH /* @min:%2epush */](_telemetryInitializerPlugin);\n          }\n          _pluginChain = createTelemetryProxyChain(sortPlugins(extensions), _config, _self);\n        }\n        return _pluginChain;\n      }\n      function _removePlugins(thePlugins, unloadState, removeComplete) {\n        if (thePlugins && thePlugins[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          var unloadChain = createTelemetryProxyChain(thePlugins, _config, _self);\n          var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);\n          unloadCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {\n            var removed = false;\n            // Remove the listed config extensions\n            var newConfigExtensions = [];\n            arrForEach(_configExtensions, function (plugin, idx) {\n              if (!_isPluginPresent(plugin, thePlugins)) {\n                newConfigExtensions[_DYN_PUSH /* @min:%2epush */](plugin);\n              } else {\n                removed = true;\n              }\n            });\n            _configExtensions = newConfigExtensions;\n            // Re-Create the channel config\n            var newChannelConfig = [];\n            if (_channelConfig) {\n              arrForEach(_channelConfig, function (queue, idx) {\n                var newQueue = [];\n                arrForEach(queue, function (channel) {\n                  if (!_isPluginPresent(channel, thePlugins)) {\n                    newQueue[_DYN_PUSH /* @min:%2epush */](channel);\n                  } else {\n                    removed = true;\n                  }\n                });\n                newChannelConfig[_DYN_PUSH /* @min:%2epush */](newQueue);\n              });\n              _channelConfig = newChannelConfig;\n            }\n            removeComplete && removeComplete(removed);\n          });\n          unloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\n        } else {\n          removeComplete(false);\n        }\n      }\n      function _flushInternalLogs() {\n        var queue = _self[_DYN_LOGGER /* @min:%2elogger */] ? _self[_DYN_LOGGER /* @min:%2elogger */].queue : [];\n        if (queue) {\n          arrForEach(queue, function (logMessage) {\n            var _a;\n            var item = (_a = {}, _a[_DYN_NAME /* @min:name */] = _internalLogsEventName ? _internalLogsEventName : \"InternalMessageId: \" + logMessage[_DYN_MESSAGE_ID /* @min:%2emessageId */], _a.iKey = getCfgValue(_config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]), _a.time = toISOString(new Date()), _a.baseType = _InternalLogMessage.dataType, _a.baseData = {\n              message: logMessage[_DYN_MESSAGE /* @min:%2emessage */]\n            }, _a);\n            _self.track(item);\n          });\n          queue[_DYN_LENGTH /* @min:%2elength */] = 0;\n        }\n      }\n      function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {\n        if (_channelControl) {\n          return _channelControl[_DYN_FLUSH /* @min:%2eflush */](isAsync, callBack, sendReason || 6 /* SendRequestReason.SdkUnload */, cbTimeout);\n        }\n        callBack && callBack(false);\n        return true;\n      }\n      function _initDebugListener() {\n        var disableDbgExt = getCfgValue(_config.disableDbgExt);\n        if (disableDbgExt === true && _debugListener) {\n          // Remove any previously loaded debug listener\n          _notificationManager[_DYN_REMOVE_NOTIFICATION_2 /* @min:%2eremoveNotificationListener */](_debugListener);\n          _debugListener = null;\n        }\n        if (_notificationManager && !_debugListener && disableDbgExt !== true) {\n          _debugListener = getDebugListener(_config);\n          _notificationManager[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](_debugListener);\n        }\n      }\n      function _initPerfManager() {\n        var enablePerfMgr = getCfgValue(_config.enablePerfMgr);\n        if (!enablePerfMgr && _cfgPerfManager) {\n          // Remove any existing config based performance manager\n          _cfgPerfManager = null;\n        }\n        if (enablePerfMgr) {\n          // Set the performance manager creation function if not defined\n          getSetValue(_config, STR_CREATE_PERF_MGR, _createPerfManager);\n        }\n      }\n      function _initExtConfig() {\n        var extConfig = getSetValue(_config, STR_EXTENSION_CONFIG, {});\n        extConfig.NotificationManager = _notificationManager;\n      }\n      function _doUpdate(updateState) {\n        var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);\n        if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {\n          updateCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);\n        }\n      }\n      function _logOrThrowError(message) {\n        var logger = _self[_DYN_LOGGER /* @min:%2elogger */];\n        if (logger) {\n          // there should always be a logger\n          _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, message);\n        } else {\n          throwError(message);\n        }\n      }\n    });\n  }\n  // Removed Stub for BaseCore.prototype.initialize.\n  // Removed Stub for BaseCore.prototype.getTransmissionControls.\n  // Removed Stub for BaseCore.prototype.track.\n  // Removed Stub for BaseCore.prototype.getProcessTelContext.\n  // Removed Stub for BaseCore.prototype.getNotifyMgr.\n  // Removed Stub for BaseCore.prototype.addNotificationListener.\n  // Removed Stub for BaseCore.prototype.removeNotificationListener.\n  // Removed Stub for BaseCore.prototype.getCookieMgr.\n  // Removed Stub for BaseCore.prototype.setCookieMgr.\n  // Removed Stub for BaseCore.prototype.getPerfMgr.\n  // Removed Stub for BaseCore.prototype.setPerfMgr.\n  // Removed Stub for BaseCore.prototype.eventCnt.\n  // Removed Stub for BaseCore.prototype.pollInternalLogs.\n  // Removed Stub for BaseCore.prototype.stopPollingInternalLogs.\n  // Removed Stub for BaseCore.prototype.addTelemetryInitializer.\n  // Removed Stub for BaseCore.prototype.unload.\n  // Removed Stub for BaseCore.prototype.getPlugin.\n  // Removed Stub for BaseCore.prototype.addPlugin.\n  // Removed Stub for BaseCore.prototype.evtNamespace.\n  // Removed Stub for BaseCore.prototype.addUnloadCb.\n  // Removed Stub for BaseCore.prototype.flush.\n  // Removed Stub for BaseCore.prototype.getTraceCtx.\n  // Removed Stub for BaseCore.prototype.setTraceCtx.\n  // Removed Stub for BaseCore.prototype.releaseQueue.\n  // Removed Stub for BaseCore.prototype._updateHook.\n  // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  // this will be removed when ES3 support is dropped.\n  BaseCore.__ieDyn = 1;\n  return BaseCore;\n}();\nexport { BaseCore };","map":{"version":3,"names":["__spreadArrayFn","__spreadArray","dynamicProto","objCreateFn","_DYN_ADD_NOTIFICATION_LIS1","_DYN_CONFIG","_DYN_FLUSH","_DYN_GET_NOTIFY_MGR","_DYN_GET_PLUGIN","_DYN_GET_PROCESS_TEL_CONT0","_DYN_IDENTIFIER","_DYN_INITIALIZE","_DYN_INSTRUMENTATION_KEY","_DYN_IS_ASYNC","_DYN_IS_INITIALIZED","_DYN_LENGTH","_DYN_LOGGER","_DYN_MESSAGE","_DYN_MESSAGE_ID","_DYN_NAME","_DYN_ON_COMPLETE","_DYN_PROCESS_NEXT","_DYN_PUSH","_DYN_REMOVE_NOTIFICATION_2","_DYN_SET_ENABLED","_DYN_SPLICE","_DYN_STOP_POLLING_INTERNA3","_DYN_TEARDOWN","_DYN_TIME","_DYN__EXTENSIONS","ChannelControllerPriority","createChannelControllerPlugin","createChannelQueues","createCookieMgr","createUniqueNamespace","getDebugListener","DiagnosticLogger","_InternalLogMessage","_throwInternal","_warnToConsole","arrForEach","arrIndexOf","getCfgValue","getSetValue","isFunction","isNullOrUndefined","objExtend","objFreeze","proxyFunctionAs","proxyFunctions","throwError","toISOString","STR_CHANNELS","STR_CORE","STR_CREATE_PERF_MGR","STR_DISABLED","STR_EVENTS_DISCARDED","STR_EVENTS_SEND_REQUEST","STR_EVENTS_SENT","STR_EXTENSIONS","STR_EXTENSION_CONFIG","STR_GET_PERF_MGR","STR_PRIORITY","PerfManager","getGblPerfMgr","createProcessTelemetryContext","createProcessTelemetryUnloadContext","createProcessTelemetryUpdateContext","createTelemetryProxyChain","_getPluginState","createDistributedTraceContext","initializePlugins","sortPlugins","TelemetryInitializerPlugin","createUnloadHandlerContainer","strValidationError","strNotificationManager","strSdkUnloadingError","strSdkNotInitialized","defaultInitConfig","loggingLevelConsole","_createPerfManager","core","notificationMgr","_validateExtensions","logger","channelPriority","allExtensions","_a","coreExtensions","extPriorities","ext","extPriority","identifier","all","_isPluginPresent","thePlugin","plugins","exists","plugin","_createDummyNotificationManager","listener","events","reason","sendReason","isAsync","BaseCore","_config","_isInitialized","_eventQueue","_notificationManager","_perfManager","_cfgPerfManager","_cookieManager","_pluginChain","_configExtensions","_coreExtensions","_channelControl","_channelConfig","_channelQueue","_isUnloading","_telemetryInitializerPlugin","_internalLogsEventName","_evtNamespace","_unloadHandlers","_debugListener","_traceCtx","_internalLogPoller","_self","_initDefaults","config","extensions","notificationManager","_initDebugListener","_initPerfManager","_initExtConfig","cfgExtensions","apply","_initPluginChain","releaseQueue","getTransmissionControls","controls","channels","queue","track","telemetryItem","iKey","Date","ver","_createTelCtx","getCookieMgr","setCookieMgr","cookieMgr","enablePerfMgr","createPerfMgr","setPerfMgr","perfMgr","eventCnt","eventQueue","event","pollInternalLogs","eventName","interval","diagnosticLogInterval","clearInterval","setInterval","_flushInternalLogs","unload","unloadComplete","cbTimeout","unloadState","flushComplete","processUnloadCtx","_getPluginChain","_doUnload","run","_flushChannels","_getPlugin","addPlugin","replaceExisting","addCb","_logOrThrowError","existingPlugin","updateState","_addPlugin","removed","added","removedPlugins_1","_removePlugins","evtNamespace","getTraceCtx","createNew","setTraceCtx","traceCtx","theExtensions","idx","_setQueue","slice","_doUpdate","pluginIdentifier","theExt","getChannel","enabled","isEnabled","pluginState","remove","removeCb","pluginsToRemove","thePlugins","removeComplete","unloadChain","unloadCtx","newConfigExtensions","newChannelConfig","newQueue","channel","logMessage","item","time","baseType","dataType","baseData","message","callBack","disableDbgExt","extConfig","NotificationManager","updateCtx","_updateHook"],"sources":["/Users/evaristlobo/Documents/GitHub/jhipster-sample-application/client/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/BaseCore.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nimport { __spreadArray } from \"tslib\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { objCreateFn } from \"@microsoft/applicationinsights-shims\";\r\nimport { _DYN_ADD_NOTIFICATION_LIS1, _DYN_CONFIG, _DYN_FLUSH, _DYN_GET_NOTIFY_MGR, _DYN_GET_PLUGIN, _DYN_GET_PROCESS_TEL_CONT0, _DYN_IDENTIFIER, _DYN_INITIALIZE, _DYN_INSTRUMENTATION_KEY, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_LOGGER, _DYN_MESSAGE, _DYN_MESSAGE_ID, _DYN_NAME, _DYN_ON_COMPLETE, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_REMOVE_NOTIFICATION_2, _DYN_SET_ENABLED, _DYN_SPLICE, _DYN_STOP_POLLING_INTERNA3, _DYN_TEARDOWN, _DYN_TIME, _DYN__EXTENSIONS } from \"../__DynamicConstants\";\r\nimport { ChannelControllerPriority, createChannelControllerPlugin, createChannelQueues } from \"./ChannelController\";\r\nimport { createCookieMgr } from \"./CookieMgr\";\r\nimport { createUniqueNamespace } from \"./DataCacheHelper\";\r\nimport { getDebugListener } from \"./DbgExtensionUtils\";\r\nimport { DiagnosticLogger, _InternalLogMessage, _throwInternal, _warnToConsole } from \"./DiagnosticLogger\";\r\nimport { arrForEach, arrIndexOf, getCfgValue, getSetValue, isFunction, isNullOrUndefined, objExtend, objFreeze, proxyFunctionAs, proxyFunctions, throwError, toISOString } from \"./HelperFuncs\";\r\nimport { STR_CHANNELS, STR_CORE, STR_CREATE_PERF_MGR, STR_DISABLED, STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_EVENTS_SENT, STR_EXTENSIONS, STR_EXTENSION_CONFIG, STR_GET_PERF_MGR, STR_PRIORITY } from \"./InternalConstants\";\r\nimport { PerfManager, getGblPerfMgr } from \"./PerfManager\";\r\nimport { createProcessTelemetryContext, createProcessTelemetryUnloadContext, createProcessTelemetryUpdateContext, createTelemetryProxyChain } from \"./ProcessTelemetryContext\";\r\nimport { _getPluginState, createDistributedTraceContext, initializePlugins, sortPlugins } from \"./TelemetryHelpers\";\r\nimport { TelemetryInitializerPlugin } from \"./TelemetryInitializerPlugin\";\r\nimport { createUnloadHandlerContainer } from \"./UnloadHandlerContainer\";\r\nvar strValidationError = \"Plugins must provide initialize method\";\r\nvar strNotificationManager = \"_notificationManager\";\r\nvar strSdkUnloadingError = \"SDK is still unloading...\";\r\nvar strSdkNotInitialized = \"SDK is not initialized\";\r\n// const strPluginUnloadFailed = \"Failed to unload plugin\";\r\nvar defaultInitConfig = {\r\n    // Have the Diagnostic Logger default to log critical errors to the console\r\n    loggingLevelConsole: 1 /* eLoggingSeverity.CRITICAL */\r\n};\r\n/**\r\n * Helper to create the default performance manager\r\n * @param core\r\n * @param notificationMgr\r\n */\r\nfunction _createPerfManager(core, notificationMgr) {\r\n    return new PerfManager(notificationMgr);\r\n}\r\nfunction _validateExtensions(logger, channelPriority, allExtensions) {\r\n    var _a;\r\n    // Concat all available extensions\r\n    var coreExtensions = [];\r\n    // Check if any two extensions have the same priority, then warn to console\r\n    // And extract the local extensions from the\r\n    var extPriorities = {};\r\n    // Extension validation\r\n    arrForEach(allExtensions, function (ext) {\r\n        // Check for ext.initialize\r\n        if (isNullOrUndefined(ext) || isNullOrUndefined(ext[_DYN_INITIALIZE /* @min:%2einitialize */])) {\r\n            throwError(strValidationError);\r\n        }\r\n        var extPriority = ext[STR_PRIORITY /* @min:%2epriority */];\r\n        var identifier = ext[_DYN_IDENTIFIER /* @min:%2eidentifier */];\r\n        if (ext && extPriority) {\r\n            if (!isNullOrUndefined(extPriorities[extPriority])) {\r\n                _warnToConsole(logger, \"Two extensions have same priority #\" + extPriority + \" - \" + extPriorities[extPriority] + \", \" + identifier);\r\n            }\r\n            else {\r\n                // set a value\r\n                extPriorities[extPriority] = identifier;\r\n            }\r\n        }\r\n        // Split extensions to core and channelController\r\n        if (!extPriority || extPriority < channelPriority) {\r\n            // Add to core extension that will be managed by BaseCore\r\n            coreExtensions[_DYN_PUSH /* @min:%2epush */](ext);\r\n        }\r\n    });\r\n    return _a = {\r\n            all: allExtensions\r\n        },\r\n        _a[STR_CORE /* @min:core */] = coreExtensions,\r\n        _a;\r\n}\r\nfunction _isPluginPresent(thePlugin, plugins) {\r\n    var exists = false;\r\n    arrForEach(plugins, function (plugin) {\r\n        if (plugin === thePlugin) {\r\n            exists = true;\r\n            return -1;\r\n        }\r\n    });\r\n    return exists;\r\n}\r\nfunction _createDummyNotificationManager() {\r\n    var _a;\r\n    return objCreateFn((_a = {},\r\n        _a[_DYN_ADD_NOTIFICATION_LIS1 /* @min:addNotificationListener */] = function (listener) { },\r\n        _a[_DYN_REMOVE_NOTIFICATION_2 /* @min:removeNotificationListener */] = function (listener) { },\r\n        _a[STR_EVENTS_SENT /* @min:eventsSent */] = function (events) { },\r\n        _a[STR_EVENTS_DISCARDED /* @min:eventsDiscarded */] = function (events, reason) { },\r\n        _a[STR_EVENTS_SEND_REQUEST /* @min:eventsSendRequest */] = function (sendReason, isAsync) { },\r\n        _a));\r\n}\r\nvar BaseCore = /** @class */ (function () {\r\n    function BaseCore() {\r\n        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\r\n        var _config;\r\n        var _isInitialized;\r\n        var _eventQueue;\r\n        var _notificationManager;\r\n        var _perfManager;\r\n        var _cfgPerfManager;\r\n        var _cookieManager;\r\n        var _pluginChain;\r\n        var _configExtensions;\r\n        var _coreExtensions;\r\n        var _channelControl;\r\n        var _channelConfig;\r\n        var _channelQueue;\r\n        var _isUnloading;\r\n        var _telemetryInitializerPlugin;\r\n        var _internalLogsEventName;\r\n        var _evtNamespace;\r\n        var _unloadHandlers;\r\n        var _debugListener;\r\n        var _traceCtx;\r\n        /**\r\n         * Internal log poller\r\n         */\r\n        var _internalLogPoller = 0;\r\n        dynamicProto(BaseCore, this, function (_self) {\r\n            // Set the default values (also called during teardown)\r\n            _initDefaults();\r\n            _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () { return _isInitialized; };\r\n            // Creating the self.initialize = ()\r\n            _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, extensions, logger, notificationManager) {\r\n                if (_isUnloading) {\r\n                    throwError(strSdkUnloadingError);\r\n                }\r\n                // Make sure core is only initialized once\r\n                if (_self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {\r\n                    throwError(\"Core should not be initialized more than once\");\r\n                }\r\n                _config = config || {};\r\n                _self[_DYN_CONFIG /* @min:%2econfig */] = _config;\r\n                if (isNullOrUndefined(config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */])) {\r\n                    throwError(\"Please provide instrumentation key\");\r\n                }\r\n                _notificationManager = notificationManager;\r\n                // For backward compatibility only\r\n                _self[strNotificationManager] = notificationManager;\r\n                _initDebugListener();\r\n                _initPerfManager();\r\n                // add notification to the extensions in the config so other plugins can access it\r\n                _initExtConfig();\r\n                if (logger) {\r\n                    _self[_DYN_LOGGER /* @min:%2elogger */] = logger;\r\n                }\r\n                var cfgExtensions = getSetValue(_config, STR_EXTENSIONS, []);\r\n                // Extension validation\r\n                _configExtensions = [];\r\n                _configExtensions[_DYN_PUSH /* @min:%2epush */].apply(_configExtensions, __spreadArray(__spreadArray([], extensions, false), cfgExtensions, false));\r\n                _channelConfig = getSetValue(_config, STR_CHANNELS, []);\r\n                _initPluginChain(null);\r\n                if (!_channelQueue || _channelQueue[_DYN_LENGTH /* @min:%2elength */] === 0) {\r\n                    throwError(\"No \" + STR_CHANNELS + \" available\");\r\n                }\r\n                _isInitialized = true;\r\n                _self.releaseQueue();\r\n            };\r\n            _self.getTransmissionControls = function () {\r\n                var controls = [];\r\n                if (_channelQueue) {\r\n                    arrForEach(_channelQueue, function (channels) {\r\n                        controls[_DYN_PUSH /* @min:%2epush */](channels.queue);\r\n                    });\r\n                }\r\n                return objFreeze(controls);\r\n            };\r\n            _self.track = function (telemetryItem) {\r\n                // setup default iKey if not passed in\r\n                telemetryItem.iKey = telemetryItem.iKey || _config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];\r\n                // add default timestamp if not passed in\r\n                telemetryItem[_DYN_TIME /* @min:%2etime */] = telemetryItem[_DYN_TIME /* @min:%2etime */] || toISOString(new Date());\r\n                // Common Schema 4.0\r\n                telemetryItem.ver = telemetryItem.ver || \"4.0\";\r\n                if (!_isUnloading && _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {\r\n                    // Process the telemetry plugin chain\r\n                    _createTelCtx()[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](telemetryItem);\r\n                }\r\n                else {\r\n                    // Queue events until all extensions are initialized\r\n                    _eventQueue[_DYN_PUSH /* @min:%2epush */](telemetryItem);\r\n                }\r\n            };\r\n            _self[_DYN_GET_PROCESS_TEL_CONT0 /* @min:%2egetProcessTelContext */] = _createTelCtx;\r\n            _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */] = function () {\r\n                if (!_notificationManager) {\r\n                    // Create Dummy notification manager\r\n                    _notificationManager = _createDummyNotificationManager();\r\n                    // For backward compatibility only\r\n                    _self[strNotificationManager] = _notificationManager;\r\n                }\r\n                return _notificationManager;\r\n            };\r\n            /**\r\n             * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.\r\n             * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be\r\n             * called.\r\n             * @param {INotificationListener} listener - An INotificationListener object.\r\n             */\r\n            _self[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {\r\n                if (_notificationManager) {\r\n                    _notificationManager[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](listener);\r\n                }\r\n            };\r\n            /**\r\n             * Removes all instances of the listener.\r\n             * @param {INotificationListener} listener - INotificationListener to remove.\r\n             */\r\n            _self[_DYN_REMOVE_NOTIFICATION_2 /* @min:%2eremoveNotificationListener */] = function (listener) {\r\n                if (_notificationManager) {\r\n                    _notificationManager[_DYN_REMOVE_NOTIFICATION_2 /* @min:%2eremoveNotificationListener */](listener);\r\n                }\r\n            };\r\n            _self.getCookieMgr = function () {\r\n                if (!_cookieManager) {\r\n                    _cookieManager = createCookieMgr(_config, _self[_DYN_LOGGER /* @min:%2elogger */]);\r\n                }\r\n                return _cookieManager;\r\n            };\r\n            _self.setCookieMgr = function (cookieMgr) {\r\n                _cookieManager = cookieMgr;\r\n            };\r\n            _self[STR_GET_PERF_MGR /* @min:%2egetPerfMgr */] = function () {\r\n                if (!_perfManager && !_cfgPerfManager) {\r\n                    if (getCfgValue(_config.enablePerfMgr)) {\r\n                        var createPerfMgr = getCfgValue(_config[STR_CREATE_PERF_MGR /* @min:%2ecreatePerfMgr */]);\r\n                        if (isFunction(createPerfMgr)) {\r\n                            _cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]());\r\n                        }\r\n                    }\r\n                }\r\n                return _perfManager || _cfgPerfManager || getGblPerfMgr();\r\n            };\r\n            _self.setPerfMgr = function (perfMgr) {\r\n                _perfManager = perfMgr;\r\n            };\r\n            _self.eventCnt = function () {\r\n                return _eventQueue[_DYN_LENGTH /* @min:%2elength */];\r\n            };\r\n            _self.releaseQueue = function () {\r\n                if (_isInitialized && _eventQueue[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    var eventQueue = _eventQueue;\r\n                    _eventQueue = [];\r\n                    arrForEach(eventQueue, function (event) {\r\n                        _createTelCtx()[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](event);\r\n                    });\r\n                }\r\n            };\r\n            /**\r\n             * Periodically check logger.queue for log messages to be flushed\r\n             */\r\n            _self.pollInternalLogs = function (eventName) {\r\n                _internalLogsEventName = eventName || null;\r\n                var interval = getCfgValue(_config.diagnosticLogInterval);\r\n                if (!interval || !(interval > 0)) {\r\n                    interval = 10000;\r\n                }\r\n                if (_internalLogPoller) {\r\n                    clearInterval(_internalLogPoller);\r\n                }\r\n                _internalLogPoller = setInterval(function () {\r\n                    _flushInternalLogs();\r\n                }, interval);\r\n                return _internalLogPoller;\r\n            };\r\n            /**\r\n             * Stop polling log messages from logger.queue\r\n             */\r\n            _self[_DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */] = function () {\r\n                if (_internalLogPoller) {\r\n                    clearInterval(_internalLogPoller);\r\n                    _internalLogPoller = 0;\r\n                    _flushInternalLogs();\r\n                }\r\n            };\r\n            // Add addTelemetryInitializer\r\n            proxyFunctions(_self, function () { return _telemetryInitializerPlugin; }, [\"addTelemetryInitializer\"]);\r\n            _self.unload = function (isAsync, unloadComplete, cbTimeout) {\r\n                var _a;\r\n                if (isAsync === void 0) { isAsync = true; }\r\n                if (!_isInitialized) {\r\n                    // The SDK is not initialized\r\n                    throwError(strSdkNotInitialized);\r\n                }\r\n                // Check if the SDK still unloading so throw\r\n                if (_isUnloading) {\r\n                    // The SDK is already unloading\r\n                    throwError(strSdkUnloadingError);\r\n                }\r\n                var unloadState = (_a = {\r\n                        reason: 50 /* TelemetryUnloadReason.SdkUnload */\r\n                    },\r\n                    _a[_DYN_IS_ASYNC /* @min:isAsync */] = isAsync,\r\n                    _a.flushComplete = false,\r\n                    _a);\r\n                var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);\r\n                processUnloadCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {\r\n                    _initDefaults();\r\n                    unloadComplete && unloadComplete(unloadState);\r\n                }, _self);\r\n                function _doUnload(flushComplete) {\r\n                    unloadState.flushComplete = flushComplete;\r\n                    _isUnloading = true;\r\n                    // Run all of the unload handlers first (before unloading the plugins)\r\n                    _unloadHandlers.run(processUnloadCtx, unloadState);\r\n                    // Stop polling the internal logs\r\n                    _self[_DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */]();\r\n                    // Start unloading the components, from this point onwards the SDK should be considered to be in an unstable state\r\n                    processUnloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\r\n                }\r\n                if (!_flushChannels(isAsync, _doUnload, 6 /* SendRequestReason.SdkUnload */, cbTimeout)) {\r\n                    _doUnload(false);\r\n                }\r\n            };\r\n            _self[_DYN_GET_PLUGIN /* @min:%2egetPlugin */] = _getPlugin;\r\n            _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {\r\n                if (!plugin) {\r\n                    addCb && addCb(false);\r\n                    _logOrThrowError(strValidationError);\r\n                    return;\r\n                }\r\n                var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */]);\r\n                if (existingPlugin && !replaceExisting) {\r\n                    addCb && addCb(false);\r\n                    _logOrThrowError(\"Plugin [\" + plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"] is already loaded!\");\r\n                    return;\r\n                }\r\n                var updateState = {\r\n                    reason: 16 /* TelemetryUpdateReason.PluginAdded */\r\n                };\r\n                function _addPlugin(removed) {\r\n                    _configExtensions[_DYN_PUSH /* @min:%2epush */](plugin);\r\n                    updateState.added = [plugin];\r\n                    // Re-Initialize the plugin chain\r\n                    _initPluginChain(updateState);\r\n                    addCb && addCb(true);\r\n                }\r\n                if (existingPlugin) {\r\n                    var removedPlugins_1 = [existingPlugin.plugin];\r\n                    var unloadState = {\r\n                        reason: 2 /* TelemetryUnloadReason.PluginReplace */,\r\n                        isAsync: !!isAsync\r\n                    };\r\n                    _removePlugins(removedPlugins_1, unloadState, function (removed) {\r\n                        if (!removed) {\r\n                            // Previous plugin was successfully removed or was not installed\r\n                            addCb && addCb(false);\r\n                        }\r\n                        else {\r\n                            updateState.removed = removedPlugins_1;\r\n                            updateState.reason |= 32 /* TelemetryUpdateReason.PluginRemoved */;\r\n                            _addPlugin(true);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    _addPlugin(false);\r\n                }\r\n            };\r\n            _self.evtNamespace = function () {\r\n                return _evtNamespace;\r\n            };\r\n            _self[_DYN_FLUSH /* @min:%2eflush */] = _flushChannels;\r\n            _self.getTraceCtx = function (createNew) {\r\n                if (!_traceCtx) {\r\n                    _traceCtx = createDistributedTraceContext();\r\n                }\r\n                return _traceCtx;\r\n            };\r\n            _self.setTraceCtx = function (traceCtx) {\r\n                _traceCtx = traceCtx || null;\r\n            };\r\n            // Create the addUnloadCb\r\n            proxyFunctionAs(_self, \"addUnloadCb\", function () { return _unloadHandlers; }, \"add\");\r\n            function _initDefaults() {\r\n                _isInitialized = false;\r\n                // Use a default logger so initialization errors are not dropped on the floor with full logging\r\n                _config = objExtend(true, {}, defaultInitConfig);\r\n                _self[_DYN_CONFIG /* @min:%2econfig */] = _config;\r\n                _self[_DYN_LOGGER /* @min:%2elogger */] = new DiagnosticLogger(_config);\r\n                _self[_DYN__EXTENSIONS /* @min:%2e_extensions */] = [];\r\n                _telemetryInitializerPlugin = new TelemetryInitializerPlugin();\r\n                _eventQueue = [];\r\n                _notificationManager = null;\r\n                _perfManager = null;\r\n                _cfgPerfManager = null;\r\n                _cookieManager = null;\r\n                _pluginChain = null;\r\n                _coreExtensions = null;\r\n                _configExtensions = [];\r\n                _channelControl = null;\r\n                _channelConfig = null;\r\n                _channelQueue = null;\r\n                _isUnloading = false;\r\n                _internalLogsEventName = null;\r\n                _evtNamespace = createUniqueNamespace(\"AIBaseCore\", true);\r\n                _unloadHandlers = createUnloadHandlerContainer();\r\n                _traceCtx = null;\r\n            }\r\n            function _createTelCtx() {\r\n                return createProcessTelemetryContext(_getPluginChain(), _config, _self);\r\n            }\r\n            // Initialize or Re-initialize the plugins\r\n            function _initPluginChain(updateState) {\r\n                // Extension validation\r\n                var theExtensions = _validateExtensions(_self[_DYN_LOGGER /* @min:%2elogger */], ChannelControllerPriority, _configExtensions);\r\n                _coreExtensions = theExtensions[STR_CORE /* @min:%2ecore */];\r\n                _pluginChain = null;\r\n                // Sort the complete set of extensions by priority\r\n                var allExtensions = theExtensions.all;\r\n                // Initialize the Channel Queues and the channel plugins first\r\n                _channelQueue = objFreeze(createChannelQueues(_channelConfig, allExtensions, _self));\r\n                if (_channelControl) {\r\n                    // During add / remove of a plugin this may get called again, so don't re-add if already present\r\n                    // But we also want the controller as the last, so remove if already present\r\n                    // And reusing the existing instance, just in case an installed plugin has a reference and\r\n                    // is using it.\r\n                    var idx = arrIndexOf(allExtensions, _channelControl);\r\n                    if (idx !== -1) {\r\n                        allExtensions[_DYN_SPLICE /* @min:%2esplice */](idx, 1);\r\n                    }\r\n                    idx = arrIndexOf(_coreExtensions, _channelControl);\r\n                    if (idx !== -1) {\r\n                        _coreExtensions[_DYN_SPLICE /* @min:%2esplice */](idx, 1);\r\n                    }\r\n                    _channelControl._setQueue(_channelQueue);\r\n                }\r\n                else {\r\n                    _channelControl = createChannelControllerPlugin(_channelQueue, _self);\r\n                }\r\n                // Add on \"channelController\" as the last \"plugin\"\r\n                allExtensions[_DYN_PUSH /* @min:%2epush */](_channelControl);\r\n                _coreExtensions[_DYN_PUSH /* @min:%2epush */](_channelControl);\r\n                // Required to allow plugins to call core.getPlugin() during their own initialization\r\n                _self[_DYN__EXTENSIONS /* @min:%2e_extensions */] = sortPlugins(allExtensions);\r\n                // Initialize the controls\r\n                _channelControl[_DYN_INITIALIZE /* @min:%2einitialize */](_config, _self, allExtensions);\r\n                initializePlugins(_createTelCtx(), allExtensions);\r\n                // Now reset the extensions to just those being managed by Basecore\r\n                _self[_DYN__EXTENSIONS /* @min:%2e_extensions */] = objFreeze(sortPlugins(_coreExtensions || [])).slice();\r\n                if (updateState) {\r\n                    _doUpdate(updateState);\r\n                }\r\n            }\r\n            function _getPlugin(pluginIdentifier) {\r\n                var _a;\r\n                var theExt = null;\r\n                var thePlugin = null;\r\n                arrForEach(_self[_DYN__EXTENSIONS /* @min:%2e_extensions */], function (ext) {\r\n                    if (ext[_DYN_IDENTIFIER /* @min:%2eidentifier */] === pluginIdentifier && ext !== _channelControl && ext !== _telemetryInitializerPlugin) {\r\n                        thePlugin = ext;\r\n                        return -1;\r\n                    }\r\n                });\r\n                if (!thePlugin && _channelControl) {\r\n                    // Check the channel Controller\r\n                    thePlugin = _channelControl.getChannel(pluginIdentifier);\r\n                }\r\n                if (thePlugin) {\r\n                    theExt = (_a = {\r\n                            plugin: thePlugin\r\n                        },\r\n                        _a[_DYN_SET_ENABLED /* @min:setEnabled */] = function (enabled) {\r\n                            _getPluginState(thePlugin)[STR_DISABLED] = !enabled;\r\n                        },\r\n                        _a.isEnabled = function () {\r\n                            var pluginState = _getPluginState(thePlugin);\r\n                            return !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] && !pluginState[STR_DISABLED];\r\n                        },\r\n                        _a.remove = function (isAsync, removeCb) {\r\n                            var _a;\r\n                            if (isAsync === void 0) { isAsync = true; }\r\n                            var pluginsToRemove = [thePlugin];\r\n                            var unloadState = (_a = {\r\n                                    reason: 1 /* TelemetryUnloadReason.PluginUnload */\r\n                                },\r\n                                _a[_DYN_IS_ASYNC /* @min:isAsync */] = isAsync,\r\n                                _a);\r\n                            _removePlugins(pluginsToRemove, unloadState, function (removed) {\r\n                                if (removed) {\r\n                                    // Re-Initialize the plugin chain\r\n                                    _initPluginChain({\r\n                                        reason: 32 /* TelemetryUpdateReason.PluginRemoved */,\r\n                                        removed: pluginsToRemove\r\n                                    });\r\n                                }\r\n                                removeCb && removeCb(removed);\r\n                            });\r\n                        },\r\n                        _a);\r\n                }\r\n                return theExt;\r\n            }\r\n            function _getPluginChain() {\r\n                if (!_pluginChain) {\r\n                    // copy the collection of extensions\r\n                    var extensions = (_coreExtensions || []).slice();\r\n                    // During add / remove this may get called again, so don't readd if already present\r\n                    if (arrIndexOf(extensions, _telemetryInitializerPlugin) === -1) {\r\n                        extensions[_DYN_PUSH /* @min:%2epush */](_telemetryInitializerPlugin);\r\n                    }\r\n                    _pluginChain = createTelemetryProxyChain(sortPlugins(extensions), _config, _self);\r\n                }\r\n                return _pluginChain;\r\n            }\r\n            function _removePlugins(thePlugins, unloadState, removeComplete) {\r\n                if (thePlugins && thePlugins[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    var unloadChain = createTelemetryProxyChain(thePlugins, _config, _self);\r\n                    var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);\r\n                    unloadCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {\r\n                        var removed = false;\r\n                        // Remove the listed config extensions\r\n                        var newConfigExtensions = [];\r\n                        arrForEach(_configExtensions, function (plugin, idx) {\r\n                            if (!_isPluginPresent(plugin, thePlugins)) {\r\n                                newConfigExtensions[_DYN_PUSH /* @min:%2epush */](plugin);\r\n                            }\r\n                            else {\r\n                                removed = true;\r\n                            }\r\n                        });\r\n                        _configExtensions = newConfigExtensions;\r\n                        // Re-Create the channel config\r\n                        var newChannelConfig = [];\r\n                        if (_channelConfig) {\r\n                            arrForEach(_channelConfig, function (queue, idx) {\r\n                                var newQueue = [];\r\n                                arrForEach(queue, function (channel) {\r\n                                    if (!_isPluginPresent(channel, thePlugins)) {\r\n                                        newQueue[_DYN_PUSH /* @min:%2epush */](channel);\r\n                                    }\r\n                                    else {\r\n                                        removed = true;\r\n                                    }\r\n                                });\r\n                                newChannelConfig[_DYN_PUSH /* @min:%2epush */](newQueue);\r\n                            });\r\n                            _channelConfig = newChannelConfig;\r\n                        }\r\n                        removeComplete && removeComplete(removed);\r\n                    });\r\n                    unloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\r\n                }\r\n                else {\r\n                    removeComplete(false);\r\n                }\r\n            }\r\n            function _flushInternalLogs() {\r\n                var queue = _self[_DYN_LOGGER /* @min:%2elogger */] ? _self[_DYN_LOGGER /* @min:%2elogger */].queue : [];\r\n                if (queue) {\r\n                    arrForEach(queue, function (logMessage) {\r\n                        var _a;\r\n                        var item = (_a = {},\r\n                            _a[_DYN_NAME /* @min:name */] = _internalLogsEventName ? _internalLogsEventName : \"InternalMessageId: \" + logMessage[_DYN_MESSAGE_ID /* @min:%2emessageId */],\r\n                            _a.iKey = getCfgValue(_config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]),\r\n                            _a.time = toISOString(new Date()),\r\n                            _a.baseType = _InternalLogMessage.dataType,\r\n                            _a.baseData = { message: logMessage[_DYN_MESSAGE /* @min:%2emessage */] },\r\n                            _a);\r\n                        _self.track(item);\r\n                    });\r\n                    queue[_DYN_LENGTH /* @min:%2elength */] = 0;\r\n                }\r\n            }\r\n            function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {\r\n                if (_channelControl) {\r\n                    return _channelControl[_DYN_FLUSH /* @min:%2eflush */](isAsync, callBack, sendReason || 6 /* SendRequestReason.SdkUnload */, cbTimeout);\r\n                }\r\n                callBack && callBack(false);\r\n                return true;\r\n            }\r\n            function _initDebugListener() {\r\n                var disableDbgExt = getCfgValue(_config.disableDbgExt);\r\n                if (disableDbgExt === true && _debugListener) {\r\n                    // Remove any previously loaded debug listener\r\n                    _notificationManager[_DYN_REMOVE_NOTIFICATION_2 /* @min:%2eremoveNotificationListener */](_debugListener);\r\n                    _debugListener = null;\r\n                }\r\n                if (_notificationManager && !_debugListener && disableDbgExt !== true) {\r\n                    _debugListener = getDebugListener(_config);\r\n                    _notificationManager[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](_debugListener);\r\n                }\r\n            }\r\n            function _initPerfManager() {\r\n                var enablePerfMgr = getCfgValue(_config.enablePerfMgr);\r\n                if (!enablePerfMgr && _cfgPerfManager) {\r\n                    // Remove any existing config based performance manager\r\n                    _cfgPerfManager = null;\r\n                }\r\n                if (enablePerfMgr) {\r\n                    // Set the performance manager creation function if not defined\r\n                    getSetValue(_config, STR_CREATE_PERF_MGR, _createPerfManager);\r\n                }\r\n            }\r\n            function _initExtConfig() {\r\n                var extConfig = getSetValue(_config, STR_EXTENSION_CONFIG, {});\r\n                extConfig.NotificationManager = _notificationManager;\r\n            }\r\n            function _doUpdate(updateState) {\r\n                var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);\r\n                if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {\r\n                    updateCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);\r\n                }\r\n            }\r\n            function _logOrThrowError(message) {\r\n                var logger = _self[_DYN_LOGGER /* @min:%2elogger */];\r\n                if (logger) {\r\n                    // there should always be a logger\r\n                    _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, message);\r\n                }\r\n                else {\r\n                    throwError(message);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    BaseCore.prototype.initialize = function (config, extensions, logger, notificationManager) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    BaseCore.prototype.getTransmissionControls = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    BaseCore.prototype.track = function (telemetryItem) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    BaseCore.prototype.getProcessTelContext = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    BaseCore.prototype.getNotifyMgr = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.\r\n     * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be\r\n     * called.\r\n     * @param {INotificationListener} listener - An INotificationListener object.\r\n     */\r\n    BaseCore.prototype.addNotificationListener = function (listener) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Removes all instances of the listener.\r\n     * @param {INotificationListener} listener - INotificationListener to remove.\r\n     */\r\n    BaseCore.prototype.removeNotificationListener = function (listener) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Get the current cookie manager for this instance\r\n     */\r\n    BaseCore.prototype.getCookieMgr = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Set the current cookie manager for this instance\r\n     * @param cookieMgr - The manager, if set to null/undefined will cause the default to be created\r\n     */\r\n    BaseCore.prototype.setCookieMgr = function (cookieMgr) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    BaseCore.prototype.getPerfMgr = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    BaseCore.prototype.setPerfMgr = function (perfMgr) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    BaseCore.prototype.eventCnt = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return 0;\r\n    };\r\n    /**\r\n     * Periodically check logger.queue for\r\n     */\r\n    BaseCore.prototype.pollInternalLogs = function (eventName) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return 0;\r\n    };\r\n    /**\r\n     * Periodically check logger.queue for\r\n     */\r\n    BaseCore.prototype.stopPollingInternalLogs = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Add a telemetry processor to decorate or drop telemetry events.\r\n     * @param telemetryInitializer - The Telemetry Initializer function\r\n     * @returns - A ITelemetryInitializerHandler to enable the initializer to be removed\r\n     */\r\n    BaseCore.prototype.addTelemetryInitializer = function (telemetryInitializer) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Unload and Tear down the SDK and any initialized plugins, after calling this the SDK will be considered\r\n     * to be un-initialized and non-operational, re-initializing the SDK should only be attempted if the previous\r\n     * unload call return `true` stating that all plugins reported that they also unloaded, the recommended\r\n     * approach is to create a new instance and initialize that instance.\r\n     * This is due to possible unexpected side effects caused by plugins not supporting unload / teardown, unable\r\n     * to successfully remove any global references or they may just be completing the unload process asynchronously.\r\n     * @param isAsync - Can the unload be performed asynchronously (default)\r\n     * @param unloadComplete - An optional callback that will be called once the unload has completed\r\n     * @param cbTimeout - An optional timeout to wait for any flush operations to complete before proceeding with the unload. Defaults to 5 seconds.\r\n     */\r\n    BaseCore.prototype.unload = function (isAsync, unloadComplete, cbTimeout) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    BaseCore.prototype.getPlugin = function (pluginIdentifier) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Add a new plugin to the installation\r\n     * @param plugin - The new plugin to add\r\n     * @param replaceExisting - should any existing plugin be replaced, default is false\r\n     * @param doAsync - Should the add be performed asynchronously\r\n     * @param addCb - [Optional] callback to call after the plugin has been added\r\n     */\r\n    BaseCore.prototype.addPlugin = function (plugin, replaceExisting, doAsync, addCb) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Returns the unique event namespace that should be used\r\n     */\r\n    BaseCore.prototype.evtNamespace = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Add an unload handler that will be called when the SDK is being unloaded\r\n     * @param handler - the handler\r\n     */\r\n    BaseCore.prototype.addUnloadCb = function (handler) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Flush and send any batched / cached data immediately\r\n     * @param async - send data asynchronously when true (defaults to true)\r\n     * @param callBack - if specified, notify caller when send is complete, the channel should return true to indicate to the caller that it will be called.\r\n     * If the caller doesn't return true the caller should assume that it may never be called.\r\n     * @param sendReason - specify the reason that you are calling \"flush\" defaults to ManualFlush (1) if not specified\r\n     * @returns - true if the callback will be return after the flush is complete otherwise the caller should assume that any provided callback will never be called\r\n     */\r\n    BaseCore.prototype.flush = function (isAsync, callBack, sendReason) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Gets the current distributed trace context for this instance if available\r\n     * @param createNew - Optional flag to create a new instance if one doesn't currently exist, defaults to true\r\n     */\r\n    BaseCore.prototype.getTraceCtx = function (createNew) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Sets the current distributed trace context for this instance if available\r\n     */\r\n    BaseCore.prototype.setTraceCtx = function (newTracectx) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    BaseCore.prototype.releaseQueue = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Hook for Core extensions to allow them to update their own configuration before updating all of the plugins.\r\n     * @param updateCtx - The plugin update context\r\n     * @param updateState - The Update State\r\n     * @returns boolean - True means the extension class will call updateState otherwise the Core will\r\n     */\r\n    BaseCore.prototype._updateHook = function (updateCtx, updateState) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return false;\r\n    };\r\n    return BaseCore;\r\n}());\r\nexport { BaseCore };\r\n//# sourceMappingURL=BaseCore.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}