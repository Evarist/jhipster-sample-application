{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Channel, 2.8.12\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nvar _a;\nimport { __assignFn as __assign, __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { BreezeChannelIdentifier, DEFAULT_BREEZE_ENDPOINT, DEFAULT_BREEZE_PATH, DisabledPropertyName, Event, Exception, Metric, PageView, PageViewPerformance, ProcessLegacy, RemoteDependencyData, RequestHeaders, SampleRate, Trace, isInternalApplicationInsightsEndpoint, utlCanUseSessionStorage } from \"@microsoft/applicationinsights-common\";\nimport { BaseTelemetryPlugin, _throwInternal, _warnToConsole, arrForEach, createUniqueNamespace, dateNow, dumpObj, getExceptionName, getIEVersion, getJSON, getNavigator, getWindow, isArray, isBeaconsSupported, isFetchSupported, isNullOrUndefined, isXhrSupported, mergeEvtNamespace, objForEachKey, objKeys, useXDomainRequest } from \"@microsoft/applicationinsights-core-js\";\nimport { DependencyEnvelopeCreator, EventEnvelopeCreator, ExceptionEnvelopeCreator, MetricEnvelopeCreator, PageViewEnvelopeCreator, PageViewPerformanceEnvelopeCreator, TraceEnvelopeCreator } from \"./EnvelopeCreator\";\nimport { createOfflineListener } from \"./Offline\";\nimport { ArraySendBuffer, SessionStorageSendBuffer } from \"./SendBuffer\";\nimport { Serializer } from \"./Serializer\";\nimport { Sample } from \"./TelemetryProcessors/Sample\";\nimport { _DYN_BASE_TYPE, _DYN_BATCH_PAYLOADS, _DYN_BUFFER_OVERRIDE, _DYN_CLEAR, _DYN_CLEAR_SENT, _DYN_CONVERT_UNDEFINED, _DYN_COUNT, _DYN_CUSTOM_HEADERS, _DYN_DIAG_LOG, _DYN_DISABLE_INSTRUMENTAT7, _DYN_DISABLE_TELEMETRY, _DYN_DISABLE_XHR, _DYN_EMIT_LINE_DELIMITED_0, _DYN_ENABLE_SESSION_STORA4, _DYN_ENDPOINT_URL, _DYN_ENQUEUE, _DYN_EVENTS_SEND_REQUEST, _DYN_INSTRUMENTATION_KEY, _DYN_IS_BEACON_API_DISABL3, _DYN_IS_ONLINE, _DYN_IS_RETRY_DISABLED, _DYN_ITEMS_ACCEPTED, _DYN_ITEMS_RECEIVED, _DYN_LENGTH, _DYN_MARK_AS_SENT, _DYN_MAX_BATCH_INTERVAL, _DYN_MAX_BATCH_SIZE_IN_BY1, _DYN_NAME_PREFIX, _DYN_ONUNLOAD_DISABLE_BEA2, _DYN_ONUNLOAD_DISABLE_FET5, _DYN_PUSH, _DYN_SAMPLE_RATE, _DYN_SAMPLING_PERCENTAGE, _DYN_SET_REQUEST_HEADER, _DYN_TAGS, _DYN_TRIGGER_SEND, _DYN__BUFFER, _DYN__ON_ERROR, _DYN__ON_PARTIAL_SUCCESS, _DYN__ON_SUCCESS, _DYN__SENDER, _DYN__SENDER_CONFIG, _DYN__XHR_READY_STATE_CHA6 } from \"./__DynamicConstants\";\nvar FetchSyncRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)\nfunction _getResponseText(xhr) {\n  try {\n    return xhr.responseText;\n  } catch (e) {\n    // Best effort, as XHR may throw while XDR wont so just ignore\n  }\n  return null;\n}\nfunction _getDefaultAppInsightsChannelConfig() {\n  var _a;\n  var defaultValue;\n  var defaultCustomHeaders;\n  // set default values\n  return _a = {\n    endpointUrl: function endpointUrl() {\n      return DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH;\n    }\n  }, _a[_DYN_EMIT_LINE_DELIMITED_0 /* @min:emitLineDelimitedJson */] = function () {\n    return false;\n  }, _a[_DYN_MAX_BATCH_INTERVAL /* @min:maxBatchInterval */] = function () {\n    return 15000;\n  }, _a[_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:maxBatchSizeInBytes */] = function () {\n    return 102400;\n  }, _a[_DYN_DISABLE_TELEMETRY /* @min:disableTelemetry */] = function () {\n    return false;\n  }, _a[_DYN_ENABLE_SESSION_STORA4 /* @min:enableSessionStorageBuffer */] = function () {\n    return true;\n  }, _a[_DYN_BUFFER_OVERRIDE /* @min:bufferOverride */] = function () {\n    return false;\n  }, _a[_DYN_IS_RETRY_DISABLED /* @min:isRetryDisabled */] = function () {\n    return false;\n  }, _a[_DYN_IS_BEACON_API_DISABL3 /* @min:isBeaconApiDisabled */] = function () {\n    return true;\n  }, _a[_DYN_DISABLE_XHR /* @min:disableXhr */] = function () {\n    return false;\n  }, _a[_DYN_ONUNLOAD_DISABLE_FET5 /* @min:onunloadDisableFetch */] = function () {\n    return false;\n  }, _a[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:onunloadDisableBeacon */] = function () {\n    return false;\n  }, _a[_DYN_INSTRUMENTATION_KEY /* @min:instrumentationKey */] = function () {\n    return defaultValue;\n  }, _a[_DYN_NAME_PREFIX /* @min:namePrefix */] = function () {\n    return defaultValue;\n  }, _a[_DYN_SAMPLING_PERCENTAGE /* @min:samplingPercentage */] = function () {\n    return 100;\n  }, _a[_DYN_CUSTOM_HEADERS /* @min:customHeaders */] = function () {\n    return defaultCustomHeaders;\n  }, _a[_DYN_CONVERT_UNDEFINED /* @min:convertUndefined */] = function () {\n    return defaultValue;\n  }, _a.eventsLimitInMem = function () {\n    return 10000;\n  }, _a;\n}\nvar EnvelopeTypeCreator = (_a = {}, _a[Event.dataType] = EventEnvelopeCreator, _a[Trace.dataType] = TraceEnvelopeCreator, _a[PageView.dataType] = PageViewEnvelopeCreator, _a[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator, _a[Exception.dataType] = ExceptionEnvelopeCreator, _a[Metric.dataType] = MetricEnvelopeCreator, _a[RemoteDependencyData.dataType] = DependencyEnvelopeCreator, _a);\nvar Sender = /** @class */function (_super) {\n  __extends(Sender, _super);\n  function Sender() {\n    var _this = _super.call(this) || this;\n    _this.priority = 1001;\n    _this.identifier = BreezeChannelIdentifier;\n    /**\r\n     * The configuration for this sender instance\r\n     */\n    _this._senderConfig = _getDefaultAppInsightsChannelConfig();\n    // Don't set the defaults here, set them in the _initDefaults() as this is also called during unload\n    var _consecutiveErrors; // How many times in a row a retryable error condition has occurred.\n    var _retryAt; // The time to retry at in milliseconds from 1970/01/01 (this makes the timer calculation easy).\n    var _lastSend; // The time of the last send operation.\n    var _paused; // Flag indicating that the sending should be paused\n    var _timeoutHandle; // Handle to the timer for delayed sending of batches of data.\n    var _serializer;\n    var _stamp_specific_redirects;\n    var _headers;\n    var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)\n    var _fallbackSender; // The sender to use if the payload size is too large\n    var _syncUnloadSender; // The identified sender to use for the synchronous unload stage\n    var _offlineListener;\n    var _evtNamespace;\n    dynamicProto(Sender, _this, function (_self, _base) {\n      _initDefaults();\n      _self.pause = function () {\n        _clearScheduledTimer();\n        _paused = true;\n      };\n      _self.resume = function () {\n        if (_paused) {\n          _paused = false;\n          _retryAt = null;\n          // flush if we have exceeded the max-size already\n          if (_self._buffer.size() > _self._senderConfig[_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:%2emaxBatchSizeInBytes */]()) {\n            _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 10 /* SendRequestReason.MaxBatchSize */);\n          }\n\n          _setupTimer();\n        }\n      };\n      _self.flush = function (isAsync, callBack, sendReason) {\n        if (isAsync === void 0) {\n          isAsync = true;\n        }\n        if (!_paused) {\n          // Clear the normal schedule timer as we are going to try and flush ASAP\n          _clearScheduledTimer();\n          try {\n            _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](isAsync, null, sendReason || 1 /* SendRequestReason.ManualFlush */);\n          } catch (e) {\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 22 /* _eInternalMessageId.FlushFailed */, \"flush failed, telemetry will not be collected: \" + getExceptionName(e), {\n              exception: dumpObj(e)\n            });\n          }\n        }\n      };\n      _self.onunloadFlush = function () {\n        if (!_paused) {\n          if ((_self._senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */]() === false || _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */]() === false) && isBeaconsSupported()) {\n            try {\n              _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, _doUnloadSend, 2 /* SendRequestReason.Unload */);\n            } catch (e) {\n              _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, \"failed to flush with beacon sender on page unload, telemetry will not be collected: \" + getExceptionName(e), {\n                exception: dumpObj(e)\n              });\n            }\n          } else {\n            _self.flush();\n          }\n        }\n      };\n      _self.addHeader = function (name, value) {\n        _headers[name] = value;\n      };\n      _self.initialize = function (config, core, extensions, pluginChain) {\n        if (_self.isInitialized()) {\n          _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender is already initialized\");\n        }\n        _base.initialize(config, core, extensions, pluginChain);\n        var ctx = _self._getTelCtx();\n        var identifier = _self.identifier;\n        _serializer = new Serializer(core.logger);\n        _consecutiveErrors = 0;\n        _retryAt = null;\n        _lastSend = 0;\n        _self[_DYN__SENDER /* @min:%2e_sender */] = null;\n        _stamp_specific_redirects = 0;\n        var diagLog = _self[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\n        _evtNamespace = mergeEvtNamespace(createUniqueNamespace(\"Sender\"), core.evtNamespace && core.evtNamespace());\n        _offlineListener = createOfflineListener(_evtNamespace);\n        // TODO v3.x: Change the ISenderConfig to not be function calls\n        var defaultConfig = _getDefaultAppInsightsChannelConfig();\n        objForEachKey(defaultConfig, function (field, value) {\n          _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][field] = function () {\n            var theValue = ctx.getConfig(identifier, field, value());\n            if (!theValue && field === \"endpointUrl\") {\n              // Use the default value (handles empty string in the configuration)\n              theValue = value();\n            }\n            return theValue;\n          };\n        });\n        var useSessionStorage = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENABLE_SESSION_STORA4 /* @min:%2eenableSessionStorageBuffer */]() && !!(_self._senderConfig[_DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */]() || utlCanUseSessionStorage());\n        _self[_DYN__BUFFER /* @min:%2e_buffer */] = useSessionStorage ? new SessionStorageSendBuffer(diagLog, _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */]) : new ArraySendBuffer(diagLog, _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */]);\n        _self._sample = new Sample(_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_SAMPLING_PERCENTAGE /* @min:%2esamplingPercentage */](), diagLog);\n        if (!_validateInstrumentationKey(config)) {\n          _throwInternal(diagLog, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, \"Invalid Instrumentation key \" + config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]);\n        }\n\n        if (!isInternalApplicationInsightsEndpoint(_self._senderConfig.endpointUrl()) && _self._senderConfig.customHeaders() && _self._senderConfig.customHeaders()[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          arrForEach(_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */](), function (customHeader) {\n            _this.addHeader(customHeader.header, customHeader.value);\n          });\n        }\n        var senderConfig = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */];\n        var sendPostFunc = null;\n        if (!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */]() && useXDomainRequest()) {\n          sendPostFunc = _xdrSender; // IE 8 and 9\n        } else if (!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */]() && isXhrSupported()) {\n          sendPostFunc = _xhrSender;\n        }\n        if (!sendPostFunc && isFetchSupported()) {\n          sendPostFunc = _fetchSender;\n        }\n        // always fallback to XHR\n        _fallbackSender = sendPostFunc || _xhrSender;\n        if (!senderConfig[_DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */]() && isBeaconsSupported()) {\n          // Config is set to always used beacon sending\n          sendPostFunc = _beaconSender;\n        }\n        _self[_DYN__SENDER /* @min:%2e_sender */] = sendPostFunc || _xhrSender;\n        if (!senderConfig[_DYN_ONUNLOAD_DISABLE_FET5 /* @min:%2eonunloadDisableFetch */]() && isFetchSupported(true)) {\n          // Try and use the fetch with keepalive\n          _syncUnloadSender = _fetchKeepAliveSender;\n        } else if (isBeaconsSupported()) {\n          // Try and use sendBeacon\n          _syncUnloadSender = _beaconSender;\n        } else if (!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */]() && useXDomainRequest()) {\n          _syncUnloadSender = _xdrSender; // IE 8 and 9\n        } else if (!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */]() && isXhrSupported()) {\n          _syncUnloadSender = _xhrSender;\n        } else {\n          _syncUnloadSender = _fallbackSender;\n        }\n      };\n      _self.processTelemetry = function (telemetryItem, itemCtx) {\n        itemCtx = _self._getTelCtx(itemCtx);\n        var diagLogger = itemCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\n        try {\n          // if master off switch is set, don't send any data\n          if (_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_DISABLE_TELEMETRY /* @min:%2edisableTelemetry */]()) {\n            // Do not send/save data\n            return;\n          }\n          // validate input\n          if (!telemetryItem) {\n            _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 7 /* _eInternalMessageId.CannotSendEmptyTelemetry */, \"Cannot send empty telemetry\");\n            return;\n          }\n          // validate event\n          if (telemetryItem.baseData && !telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */]) {\n            _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 70 /* _eInternalMessageId.InvalidEvent */, \"Cannot send telemetry without baseData and baseType\");\n            return;\n          }\n          if (!telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */]) {\n            // Default\n            telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */] = \"EventData\";\n          }\n          // ensure a sender was constructed\n          if (!_self[_DYN__SENDER /* @min:%2e_sender */]) {\n            _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender was not initialized\");\n            return;\n          }\n          // check if this item should be sampled in, else add sampleRate tag\n          if (!_isSampledIn(telemetryItem)) {\n            // Item is sampled out, do not send it\n            _throwInternal(diagLogger, 2 /* eLoggingSeverity.WARNING */, 33 /* _eInternalMessageId.TelemetrySampledAndNotSent */, \"Telemetry item was sampled out and not sent\", {\n              SampleRate: _self._sample[_DYN_SAMPLE_RATE /* @min:%2esampleRate */]\n            });\n            return;\n          } else {\n            telemetryItem[SampleRate] = _self._sample[_DYN_SAMPLE_RATE /* @min:%2esampleRate */];\n          }\n\n          var convertUndefined = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_CONVERT_UNDEFINED /* @min:%2econvertUndefined */]() || undefined;\n          // construct an envelope that Application Insights endpoint can understand\n          // if ikey of telemetry is provided and not empty, envelope will use this iKey instead of senderConfig iKey\n          var defaultEnvelopeIkey = telemetryItem.iKey || _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]();\n          var aiEnvelope_1 = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, convertUndefined);\n          if (!aiEnvelope_1) {\n            _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 47 /* _eInternalMessageId.CreateEnvelopeError */, \"Unable to create an AppInsights envelope\");\n            return;\n          }\n          var doNotSendItem_1 = false;\n          // this is for running in legacy mode, where customer may already have a custom initializer present\n          if (telemetryItem[_DYN_TAGS /* @min:%2etags */] && telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy]) {\n            arrForEach(telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy], function (callBack) {\n              try {\n                if (callBack && callBack(aiEnvelope_1) === false) {\n                  doNotSendItem_1 = true;\n                  _warnToConsole(diagLogger, \"Telemetry processor check returns false\");\n                }\n              } catch (e) {\n                // log error but dont stop executing rest of the telemetry initializers\n                // doNotSendItem = true;\n                _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 64 /* _eInternalMessageId.TelemetryInitializerFailed */, \"One of telemetry initializers failed, telemetry item will not be sent: \" + getExceptionName(e), {\n                  exception: dumpObj(e)\n                }, true);\n              }\n            });\n            delete telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy];\n          }\n          if (doNotSendItem_1) {\n            return; // do not send, no need to execute next plugin\n          }\n          // check if the incoming payload is too large, truncate if necessary\n          var payload = _serializer.serialize(aiEnvelope_1);\n          // flush if we would exceed the max-size limit by adding this item\n          var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\n          var bufferSize = buffer.size();\n          if (bufferSize + payload[_DYN_LENGTH /* @min:%2elength */] > _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:%2emaxBatchSizeInBytes */]()) {\n            if (!_offlineListener || _offlineListener[_DYN_IS_ONLINE /* @min:%2eisOnline */]()) {\n              // only trigger send when currently online\n              _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 10 /* SendRequestReason.MaxBatchSize */);\n            }\n          }\n          // enqueue the payload\n          buffer[_DYN_ENQUEUE /* @min:%2eenqueue */](payload);\n          // ensure an invocation timeout is set\n          _setupTimer();\n        } catch (e) {\n          _throwInternal(diagLogger, 2 /* eLoggingSeverity.WARNING */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, \"Failed adding telemetry to the sender's buffer, some telemetry will be lost: \" + getExceptionName(e), {\n            exception: dumpObj(e)\n          });\n        }\n        // hand off the telemetry item to the next plugin\n        _self.processNext(telemetryItem, itemCtx);\n      };\n      /**\r\n       * xhr state changes\r\n       */\n      _self[_DYN__XHR_READY_STATE_CHA6 /* @min:%2e_xhrReadyStateChange */] = function (xhr, payload, countOfItemsInPayload) {\n        if (xhr.readyState === 4) {\n          _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, _formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);\n        }\n      };\n      /**\r\n       * Immediately send buffered data\r\n       * @param async {boolean} - Indicates if the events should be sent asynchronously\r\n       * @param forcedSender {SenderFunction} - Indicates the forcedSender, undefined if not passed\r\n       */\n      _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */] = function (async, forcedSender, sendReason) {\n        if (async === void 0) {\n          async = true;\n        }\n        if (!_paused) {\n          try {\n            var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\n            // Send data only if disableTelemetry is false\n            if (!_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_DISABLE_TELEMETRY /* @min:%2edisableTelemetry */]()) {\n              if (buffer[_DYN_COUNT /* @min:%2ecount */]() > 0) {\n                var payload = buffer.getItems();\n                _notifySendRequest(sendReason || 0 /* SendRequestReason.Undefined */, async);\n                // invoke send\n                if (forcedSender) {\n                  forcedSender.call(_this, payload, async);\n                } else {\n                  _self[_DYN__SENDER /* @min:%2e_sender */](payload, async);\n                }\n              }\n              // update lastSend time to enable throttling\n              _lastSend = +new Date();\n            } else {\n              buffer[_DYN_CLEAR /* @min:%2eclear */]();\n            }\n\n            _clearScheduledTimer();\n          } catch (e) {\n            /* Ignore this error for IE under v10 */\n            var ieVer = getIEVersion();\n            if (!ieVer || ieVer > 9) {\n              _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 40 /* _eInternalMessageId.TransmissionFailed */, \"Telemetry transmission failed, some telemetry will be lost: \" + getExceptionName(e), {\n                exception: dumpObj(e)\n              });\n            }\n          }\n        }\n      };\n      _self._doTeardown = function (unloadCtx, unloadState) {\n        _self.onunloadFlush();\n        _offlineListener.unload();\n        _initDefaults();\n      };\n      /**\r\n       * error handler\r\n       */\n      _self[_DYN__ON_ERROR /* @min:%2e_onError */] = function (payload, message, event) {\n        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, \"Failed to send telemetry.\", {\n          message: message\n        });\n        _self._buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\n      };\n      /**\r\n       * partial success handler\r\n       */\n      _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */] = function (payload, results) {\n        var failed = [];\n        var retry = [];\n        // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.\n        var errors = results.errors.reverse();\n        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n          var error = errors_1[_i];\n          var extracted = payload.splice(error.index, 1)[0];\n          if (_isRetriable(error.statusCode)) {\n            retry[_DYN_PUSH /* @min:%2epush */](extracted);\n          } else {\n            // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).\n            failed[_DYN_PUSH /* @min:%2epush */](extracted);\n          }\n        }\n        if (payload[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]);\n        }\n\n        if (failed[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          _self[_DYN__ON_ERROR /* @min:%2e_onError */](failed, _formatErrorMessageXhr(null, [\"partial success\", results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */], \"of\", results.itemsReceived].join(\" \")));\n        }\n        if (retry[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          _resendPayload(retry);\n          _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \"Partial success. \" + \"Delivered: \" + payload[_DYN_LENGTH /* @min:%2elength */] + \", Failed: \" + failed[_DYN_LENGTH /* @min:%2elength */] + \". Will retry to send \" + retry[_DYN_LENGTH /* @min:%2elength */] + \" our of \" + results[_DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] + \" items\");\n        }\n      };\n      /**\r\n       * success handler\r\n       */\n      _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */] = function (payload, countOfItemsInPayload) {\n        _self._buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\n      };\n      /**\r\n       * xdr state changes\r\n       */\n      _self._xdrOnLoad = function (xdr, payload) {\n        var responseText = _getResponseText(xdr);\n        if (xdr && (responseText + \"\" === \"200\" || responseText === \"\")) {\n          _consecutiveErrors = 0;\n          _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, 0);\n        } else {\n          var results = _parseResponse(responseText);\n          if (results && results.itemsReceived && results.itemsReceived > results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */] && !_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_RETRY_DISABLED /* @min:%2eisRetryDisabled */]()) {\n            _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, results);\n          } else {\n            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, _formatErrorMessageXdr(xdr));\n          }\n        }\n      };\n      function _isSampledIn(envelope) {\n        return _self._sample.isSampledIn(envelope);\n      }\n      function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {\n        var response = null;\n        if (!_self._appId) {\n          response = _parseResponse(res);\n          if (response && response.appId) {\n            _self._appId = response.appId;\n          }\n        }\n        if ((status < 200 || status >= 300) && status !== 0) {\n          // Update End Point url if permanent redirect or moved permanently\n          // Updates the end point url before retry\n          if (status === 301 || status === 307 || status === 308) {\n            if (!_checkAndUpdateEndPointUrl(responseUrl)) {\n              _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\n              return;\n            }\n          }\n          if (!_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_RETRY_DISABLED /* @min:%2eisRetryDisabled */]() && _isRetriable(status)) {\n            _resendPayload(payload);\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Response code \" + status + \". Will retry to send \" + payload[_DYN_LENGTH /* @min:%2elength */] + \" items.\");\n          } else {\n            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\n          }\n        } else if (_offlineListener && !_offlineListener[_DYN_IS_ONLINE /* @min:%2eisOnline */]()) {\n          // offline\n          // Note: Don't check for status == 0, since adblock gives this code\n          if (!_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_RETRY_DISABLED /* @min:%2eisRetryDisabled */]()) {\n            var offlineBackOffMultiplier = 10; // arbritrary number\n            _resendPayload(payload, offlineBackOffMultiplier);\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". Offline - Response Code: \".concat(status, \". Offline status: \").concat(!_offlineListener.isOnline(), \". Will retry to send \").concat(payload.length, \" items.\"));\n          }\n        } else {\n          // check if the xhr's responseURL or fetch's response.url is same as endpoint url\n          // TODO after 10 redirects force send telemetry with 'redirect=false' as query parameter.\n          _checkAndUpdateEndPointUrl(responseUrl);\n          if (status === 206) {\n            if (!response) {\n              response = _parseResponse(res);\n            }\n            if (response && !_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_RETRY_DISABLED /* @min:%2eisRetryDisabled */]()) {\n              _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, response);\n            } else {\n              _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\n            }\n          } else {\n            _consecutiveErrors = 0;\n            _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, countOfItemsInPayload);\n          }\n        }\n      }\n      function _checkAndUpdateEndPointUrl(responseUrl) {\n        // Maximum stamp specific redirects allowed(uncomment this when breeze is ready with not allowing redirects feature)\n        if (_stamp_specific_redirects >= 10) {\n          //  _self._senderConfig.endpointUrl = () => Sender._getDefaultAppInsightsChannelConfig().endpointUrl()+\"/?redirect=false\";\n          //  _stamp_specific_redirects = 0;\n          return false;\n        }\n        if (!isNullOrUndefined(responseUrl) && responseUrl !== \"\") {\n          if (responseUrl !== _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]()) {\n            _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = function () {\n              return responseUrl;\n            };\n            ++_stamp_specific_redirects;\n            return true;\n          }\n        }\n        return false;\n      }\n      function _doUnloadSend(payload, isAsync) {\n        if (_syncUnloadSender) {\n          // We are unloading so always call the sender with sync set to false\n          _syncUnloadSender(payload, false);\n        } else {\n          // Fallback to the previous beacon Sender (which causes a CORB warning on chrome now)\n          _beaconSender(payload, isAsync);\n        }\n      }\n      function _doBeaconSend(payload) {\n        var nav = getNavigator();\n        var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\n        var url = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]();\n        var batch = _self._buffer[_DYN_BATCH_PAYLOADS /* @min:%2ebatchPayloads */](payload);\n        // Chrome only allows CORS-safelisted values for the sendBeacon data argument\n        // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283\n        var plainTextBatch = new Blob([batch], {\n          type: \"text/plain;charset=UTF-8\"\n        });\n        // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\n        var queued = nav.sendBeacon(url, plainTextBatch);\n        if (queued) {\n          buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\n          // no response from beaconSender, clear buffer\n          _self._onSuccess(payload, payload[_DYN_LENGTH /* @min:%2elength */]);\n        }\n\n        return queued;\n      }\n      /**\r\n       * Send Beacon API request\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - not used\r\n       * Note: Beacon API does not support custom headers and we are not able to get\r\n       * appId from the backend for the correct correlation.\r\n       */\n      function _beaconSender(payload, isAsync) {\n        if (isArray(payload) && payload[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\n          if (!_doBeaconSend(payload)) {\n            // Failed to send entire payload so try and split data and try to send as much events as possible\n            var droppedPayload = [];\n            for (var lp = 0; lp < payload[_DYN_LENGTH /* @min:%2elength */]; lp++) {\n              var thePayload = payload[lp];\n              if (!_doBeaconSend([thePayload])) {\n                // Can't send anymore, so split the batch and drop the rest\n                droppedPayload[_DYN_PUSH /* @min:%2epush */](thePayload);\n              }\n            }\n            if (droppedPayload[_DYN_LENGTH /* @min:%2elength */] > 0) {\n              _fallbackSender && _fallbackSender(droppedPayload, true);\n              _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with normal sender.\");\n            }\n          }\n        }\n      }\n      /**\r\n       * Send XMLHttpRequest\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - Indicates if the request should be sent asynchronously\r\n       */\n      function _xhrSender(payload, isAsync) {\n        var xhr = new XMLHttpRequest();\n        var endPointUrl = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]();\n        try {\n          xhr[DisabledPropertyName] = true;\n        } catch (e) {\n          // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would\n          // cause the request to fail and we no telemetry would be sent\n        }\n        xhr.open(\"POST\", endPointUrl, isAsync);\n        xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](\"Content-type\", \"application/json\");\n        // append Sdk-Context request header only in case of breeze endpoint\n        if (isInternalApplicationInsightsEndpoint(endPointUrl)) {\n          xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](RequestHeaders[6 /* eRequestHeaders.sdkContextHeader */], RequestHeaders[7 /* eRequestHeaders.sdkContextHeaderAppIdRequest */]);\n        }\n\n        arrForEach(objKeys(_headers), function (headerName) {\n          xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](headerName, _headers[headerName]);\n        });\n        xhr.onreadystatechange = function () {\n          return _self._xhrReadyStateChange(xhr, payload, payload[_DYN_LENGTH /* @min:%2elength */]);\n        };\n        xhr.onerror = function (event) {\n          return _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, _formatErrorMessageXhr(xhr), event);\n        };\n        // compose an array of payloads\n        var batch = _self._buffer[_DYN_BATCH_PAYLOADS /* @min:%2ebatchPayloads */](payload);\n        xhr.send(batch);\n        _self._buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\n      }\n      function _fetchKeepAliveSender(payload, isAsync) {\n        if (isArray(payload)) {\n          var payloadSize = payload[_DYN_LENGTH /* @min:%2elength */];\n          for (var lp = 0; lp < payload[_DYN_LENGTH /* @min:%2elength */]; lp++) {\n            payloadSize += payload[lp][_DYN_LENGTH /* @min:%2elength */];\n          }\n\n          if (_syncFetchPayload + payloadSize <= FetchSyncRequestSizeLimitBytes) {\n            _doFetchSender(payload, false);\n          } else if (isBeaconsSupported()) {\n            // Fallback to beacon sender as we at least get told which events can't be scheduled\n            _beaconSender(payload, isAsync);\n          } else {\n            // Payload is going to be too big so just try and send via XHR\n            _fallbackSender && _fallbackSender(payload, true);\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with xhrSender.\");\n          }\n        }\n      }\n      /**\r\n       * Send fetch API request\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - not used\r\n       */\n      function _fetchSender(payload, isAsync) {\n        _doFetchSender(payload, true);\n      }\n      /**\r\n       * Send fetch API request\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - For fetch this identifies whether we are \"unloading\" (false) or a normal request\r\n       */\n      function _doFetchSender(payload, isAsync) {\n        var _a;\n        var endPointUrl = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]();\n        var batch = _self._buffer[_DYN_BATCH_PAYLOADS /* @min:%2ebatchPayloads */](payload);\n        var plainTextBatch = new Blob([batch], {\n          type: \"application/json\"\n        });\n        var requestHeaders = new Headers();\n        var batchLength = batch[_DYN_LENGTH /* @min:%2elength */];\n        var ignoreResponse = false;\n        var responseHandled = false;\n        // append Sdk-Context request header only in case of breeze endpoint\n        if (isInternalApplicationInsightsEndpoint(endPointUrl)) {\n          requestHeaders.append(RequestHeaders[6 /* eRequestHeaders.sdkContextHeader */], RequestHeaders[7 /* eRequestHeaders.sdkContextHeaderAppIdRequest */]);\n        }\n\n        arrForEach(objKeys(_headers), function (headerName) {\n          requestHeaders.append(headerName, _headers[headerName]);\n        });\n        var init = (_a = {\n          method: \"POST\",\n          headers: requestHeaders,\n          body: plainTextBatch\n        }, _a[DisabledPropertyName] = true // Mark so we don't attempt to track this request\n        , _a);\n        if (!isAsync) {\n          init.keepalive = true;\n          // As a sync request (during unload), it is unlikely that we will get a chance to process the response so\n          // just like beacon send assume that the events have been accepted and processed\n          ignoreResponse = true;\n          _syncFetchPayload += batchLength;\n        }\n        var request = new Request(endPointUrl, init);\n        try {\n          // Also try and tag the request (just in case the value in init is not copied over)\n          request[DisabledPropertyName] = true;\n        } catch (e) {\n          // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would\n          // cause the request to fail and we no telemetry would be sent\n        }\n        _self._buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\n        try {\n          fetch(request).then(function (response) {\n            if (!isAsync) {\n              _syncFetchPayload -= batchLength;\n              batchLength = 0;\n            }\n            if (!responseHandled) {\n              responseHandled = true;\n              /**\r\n               * The Promise returned from fetch() wonâ€™t reject on HTTP error status even if the response is an HTTP 404 or 500.\r\n               * Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure\r\n               * or if anything prevented the request from completing.\r\n               */\n              if (!response.ok) {\n                _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, response.statusText);\n              } else {\n                response.text().then(function (text) {\n                  _checkResponsStatus(response.status, payload, response.url, payload[_DYN_LENGTH /* @min:%2elength */], response.statusText, text);\n                });\n              }\n            }\n          })[\"catch\"](function (error) {\n            if (!isAsync) {\n              _syncFetchPayload -= batchLength;\n              batchLength = 0;\n            }\n            if (!responseHandled) {\n              responseHandled = true;\n              _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, error.message);\n            }\n          });\n        } catch (e) {\n          if (!responseHandled) {\n            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, dumpObj(e));\n          }\n        }\n        if (ignoreResponse && !responseHandled) {\n          // Assume success during unload processing as we most likely won't get the response\n          responseHandled = true;\n          _self._onSuccess(payload, payload[_DYN_LENGTH /* @min:%2elength */]);\n        }\n      }\n      /**\r\n       * Parses the response from the backend.\r\n       * @param response - XMLHttpRequest or XDomainRequest response\r\n       */\n      function _parseResponse(response) {\n        try {\n          if (response && response !== \"\") {\n            var result = getJSON().parse(response);\n            if (result && result.itemsReceived && result.itemsReceived >= result[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */] && result.itemsReceived - result.itemsAccepted === result.errors[_DYN_LENGTH /* @min:%2elength */]) {\n              return result;\n            }\n          }\n        } catch (e) {\n          _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 43 /* _eInternalMessageId.InvalidBackendResponse */, \"Cannot parse the response. \" + getExceptionName(e), {\n            response: response\n          });\n        }\n        return null;\n      }\n      /**\r\n       * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).\r\n       * @param payload\r\n       */\n      function _resendPayload(payload, linearFactor) {\n        if (linearFactor === void 0) {\n          linearFactor = 1;\n        }\n        if (!payload || payload[_DYN_LENGTH /* @min:%2elength */] === 0) {\n          return;\n        }\n        var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\n        buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\n        _consecutiveErrors++;\n        for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {\n          var item = payload_1[_i];\n          buffer[_DYN_ENQUEUE /* @min:%2eenqueue */](item);\n        }\n        // setup timer\n        _setRetryTime(linearFactor);\n        _setupTimer();\n      }\n      /**\r\n       * Calculates the time to wait before retrying in case of an error based on\r\n       * http://en.wikipedia.org/wiki/Exponential_backoff\r\n       */\n      function _setRetryTime(linearFactor) {\n        var SlotDelayInSeconds = 10;\n        var delayInSeconds;\n        if (_consecutiveErrors <= 1) {\n          delayInSeconds = SlotDelayInSeconds;\n        } else {\n          var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;\n          // tslint:disable-next-line:insecure-random\n          var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;\n          backOffDelay = linearFactor * backOffDelay;\n          delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);\n        }\n        // TODO: Log the backoff time like the C# version does.\n        var retryAfterTimeSpan = dateNow() + delayInSeconds * 1000;\n        // TODO: Log the retry at time like the C# version does.\n        _retryAt = retryAfterTimeSpan;\n      }\n      /**\r\n       * Sets up the timer which triggers actually sending the data.\r\n       */\n      function _setupTimer() {\n        if (!_timeoutHandle && !_paused) {\n          var retryInterval = _retryAt ? Math.max(0, _retryAt - dateNow()) : 0;\n          var timerValue = Math.max(_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_MAX_BATCH_INTERVAL /* @min:%2emaxBatchInterval */](), retryInterval);\n          _timeoutHandle = setTimeout(function () {\n            _timeoutHandle = null;\n            _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 1 /* SendRequestReason.NormalSchedule */);\n          }, timerValue);\n        }\n      }\n      function _clearScheduledTimer() {\n        clearTimeout(_timeoutHandle);\n        _timeoutHandle = null;\n        _retryAt = null;\n      }\n      /**\r\n       * Checks if the SDK should resend the payload after receiving this status code from the backend.\r\n       * @param statusCode\r\n       */\n      function _isRetriable(statusCode) {\n        return statusCode === 401 // Unauthorized\n        || statusCode === 403 // Forbidden\n        || statusCode === 408 // Timeout\n        || statusCode === 429 // Too many requests.\n        || statusCode === 500 // Internal server error.\n        || statusCode === 502 // Bad Gateway.\n        || statusCode === 503 // Service unavailable.\n        || statusCode === 504; // Gateway timeout.\n      }\n\n      function _formatErrorMessageXhr(xhr, message) {\n        if (xhr) {\n          return \"XMLHttpRequest,Status:\" + xhr.status + \",Response:\" + _getResponseText(xhr) || xhr.response || \"\";\n        }\n        return message;\n      }\n      /**\r\n       * Send XDomainRequest\r\n       * @param payload {string} - The data payload to be sent.\r\n       * @param isAsync {boolean} - Indicates if the request should be sent asynchronously\r\n       *\r\n       * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added\r\n       * to maintain consistency with the xhrSender's contract\r\n       * Note: XDomainRequest does not support custom headers and we are not able to get\r\n       * appId from the backend for the correct correlation.\r\n       */\n      function _xdrSender(payload, isAsync) {\n        var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\n        var _window = getWindow();\n        var xdr = new XDomainRequest();\n        xdr.onload = function () {\n          return _self._xdrOnLoad(xdr, payload);\n        };\n        xdr.onerror = function (event) {\n          return _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, _formatErrorMessageXdr(xdr), event);\n        };\n        // XDomainRequest requires the same protocol as the hosting page.\n        // If the protocol doesn't match, we can't send the telemetry :(.\n        var hostingProtocol = _window && _window.location && _window.location.protocol || \"\";\n        if (_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]().lastIndexOf(hostingProtocol, 0) !== 0) {\n          _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.\");\n          buffer[_DYN_CLEAR /* @min:%2eclear */]();\n          return;\n        }\n        var endpointUrl = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]().replace(/^(https?:)/, \"\");\n        xdr.open(\"POST\", endpointUrl);\n        // compose an array of payloads\n        var batch = buffer[_DYN_BATCH_PAYLOADS /* @min:%2ebatchPayloads */](payload);\n        xdr.send(batch);\n        buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\n      }\n      function _formatErrorMessageXdr(xdr, message) {\n        if (xdr) {\n          return \"XDomainRequest,Response:\" + _getResponseText(xdr) || \"\";\n        }\n        return message;\n      }\n      // Using function lookups for backward compatibility as the getNotifyMgr() did not exist until after v2.5.6\n      function _getNotifyMgr() {\n        var func = \"getNotifyMgr\";\n        if (_self.core[func]) {\n          return _self.core[func]();\n        }\n        // using _self.core['_notificationManager'] for backward compatibility\n        return _self.core[\"_notificationManager\"];\n      }\n      function _notifySendRequest(sendRequest, isAsync) {\n        var manager = _getNotifyMgr();\n        if (manager && manager[_DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */]) {\n          try {\n            manager[_DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendRequest, isAsync);\n          } catch (e) {\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, \"send request notification failed: \" + getExceptionName(e), {\n              exception: dumpObj(e)\n            });\n          }\n        }\n      }\n      /**\r\n       * Validate UUID Format\r\n       * Specs taken from https://tools.ietf.org/html/rfc4122 and breeze repo\r\n       */\n      function _validateInstrumentationKey(config) {\n        var disableIKeyValidationFlag = isNullOrUndefined(config[_DYN_DISABLE_INSTRUMENTAT7 /* @min:%2edisableInstrumentationKeyValidation */]) ? false : config[_DYN_DISABLE_INSTRUMENTAT7 /* @min:%2edisableInstrumentationKeyValidation */];\n        if (disableIKeyValidationFlag) {\n          return true;\n        }\n        var UUID_Regex = \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\";\n        var regexp = new RegExp(UUID_Regex);\n        return regexp.test(config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]);\n      }\n\n      function _initDefaults() {\n        _self[_DYN__SENDER /* @min:%2e_sender */] = null;\n        _self[_DYN__BUFFER /* @min:%2e_buffer */] = null;\n        _self._appId = null;\n        _self._sample = null;\n        _headers = {};\n        _offlineListener = null;\n        _consecutiveErrors = 0;\n        _retryAt = null;\n        _lastSend = null;\n        _paused = false;\n        _timeoutHandle = null;\n        _serializer = null;\n        _stamp_specific_redirects = 0;\n        _syncFetchPayload = 0;\n        _fallbackSender = null;\n        _syncUnloadSender = null;\n        _evtNamespace = null;\n      }\n    });\n    return _this;\n  }\n  Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {\n    var envelope;\n    if (iKey !== orig.iKey && !isNullOrUndefined(iKey)) {\n      envelope = __assign(__assign({}, orig), {\n        iKey: iKey\n      });\n    } else {\n      envelope = orig;\n    }\n    var creator = EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator;\n    return creator(logger, envelope, convertUndefined);\n  };\n  // Removed Stub for Sender.prototype.pause.\n  // Removed Stub for Sender.prototype.resume.\n  // Removed Stub for Sender.prototype.flush.\n  // Removed Stub for Sender.prototype.onunloadFlush.\n  // Removed Stub for Sender.prototype.initialize.\n  // Removed Stub for Sender.prototype.processTelemetry.\n  // Removed Stub for Sender.prototype._xhrReadyStateChange.\n  // Removed Stub for Sender.prototype.triggerSend.\n  // Removed Stub for Sender.prototype._onError.\n  // Removed Stub for Sender.prototype._onPartialSuccess.\n  // Removed Stub for Sender.prototype._onSuccess.\n  // Removed Stub for Sender.prototype._xdrOnLoad.\n  // Removed Stub for Sender.prototype.addHeader.\n  return Sender;\n}(BaseTelemetryPlugin);\nexport { Sender };","map":{"version":3,"names":["_a","__assignFn","__assign","__extendsFn","__extends","dynamicProto","BreezeChannelIdentifier","DEFAULT_BREEZE_ENDPOINT","DEFAULT_BREEZE_PATH","DisabledPropertyName","Event","Exception","Metric","PageView","PageViewPerformance","ProcessLegacy","RemoteDependencyData","RequestHeaders","SampleRate","Trace","isInternalApplicationInsightsEndpoint","utlCanUseSessionStorage","BaseTelemetryPlugin","_throwInternal","_warnToConsole","arrForEach","createUniqueNamespace","dateNow","dumpObj","getExceptionName","getIEVersion","getJSON","getNavigator","getWindow","isArray","isBeaconsSupported","isFetchSupported","isNullOrUndefined","isXhrSupported","mergeEvtNamespace","objForEachKey","objKeys","useXDomainRequest","DependencyEnvelopeCreator","EventEnvelopeCreator","ExceptionEnvelopeCreator","MetricEnvelopeCreator","PageViewEnvelopeCreator","PageViewPerformanceEnvelopeCreator","TraceEnvelopeCreator","createOfflineListener","ArraySendBuffer","SessionStorageSendBuffer","Serializer","Sample","_DYN_BASE_TYPE","_DYN_BATCH_PAYLOADS","_DYN_BUFFER_OVERRIDE","_DYN_CLEAR","_DYN_CLEAR_SENT","_DYN_CONVERT_UNDEFINED","_DYN_COUNT","_DYN_CUSTOM_HEADERS","_DYN_DIAG_LOG","_DYN_DISABLE_INSTRUMENTAT7","_DYN_DISABLE_TELEMETRY","_DYN_DISABLE_XHR","_DYN_EMIT_LINE_DELIMITED_0","_DYN_ENABLE_SESSION_STORA4","_DYN_ENDPOINT_URL","_DYN_ENQUEUE","_DYN_EVENTS_SEND_REQUEST","_DYN_INSTRUMENTATION_KEY","_DYN_IS_BEACON_API_DISABL3","_DYN_IS_ONLINE","_DYN_IS_RETRY_DISABLED","_DYN_ITEMS_ACCEPTED","_DYN_ITEMS_RECEIVED","_DYN_LENGTH","_DYN_MARK_AS_SENT","_DYN_MAX_BATCH_INTERVAL","_DYN_MAX_BATCH_SIZE_IN_BY1","_DYN_NAME_PREFIX","_DYN_ONUNLOAD_DISABLE_BEA2","_DYN_ONUNLOAD_DISABLE_FET5","_DYN_PUSH","_DYN_SAMPLE_RATE","_DYN_SAMPLING_PERCENTAGE","_DYN_SET_REQUEST_HEADER","_DYN_TAGS","_DYN_TRIGGER_SEND","_DYN__BUFFER","_DYN__ON_ERROR","_DYN__ON_PARTIAL_SUCCESS","_DYN__ON_SUCCESS","_DYN__SENDER","_DYN__SENDER_CONFIG","_DYN__XHR_READY_STATE_CHA6","FetchSyncRequestSizeLimitBytes","_getResponseText","xhr","responseText","e","_getDefaultAppInsightsChannelConfig","defaultValue","defaultCustomHeaders","endpointUrl","eventsLimitInMem","EnvelopeTypeCreator","dataType","Sender","_super","_this","call","priority","identifier","_senderConfig","_consecutiveErrors","_retryAt","_lastSend","_paused","_timeoutHandle","_serializer","_stamp_specific_redirects","_headers","_syncFetchPayload","_fallbackSender","_syncUnloadSender","_offlineListener","_evtNamespace","_self","_base","_initDefaults","pause","_clearScheduledTimer","resume","_buffer","size","_setupTimer","flush","isAsync","callBack","sendReason","exception","onunloadFlush","_doUnloadSend","addHeader","name","value","initialize","config","core","extensions","pluginChain","isInitialized","ctx","_getTelCtx","logger","diagLog","evtNamespace","defaultConfig","field","theValue","getConfig","useSessionStorage","_sample","_validateInstrumentationKey","customHeaders","customHeader","header","senderConfig","sendPostFunc","_xdrSender","_xhrSender","_fetchSender","_beaconSender","_fetchKeepAliveSender","processTelemetry","telemetryItem","itemCtx","diagLogger","baseData","_isSampledIn","convertUndefined","undefined","defaultEnvelopeIkey","iKey","aiEnvelope_1","constructEnvelope","doNotSendItem_1","payload","serialize","buffer","bufferSize","processNext","countOfItemsInPayload","readyState","_checkResponsStatus","status","responseURL","_formatErrorMessageXhr","response","async","forcedSender","getItems","_notifySendRequest","Date","ieVer","_doTeardown","unloadCtx","unloadState","unload","message","event","results","failed","retry","errors","reverse","_i","errors_1","length","error","extracted","splice","index","_isRetriable","statusCode","itemsReceived","join","_resendPayload","_xdrOnLoad","xdr","_parseResponse","_formatErrorMessageXdr","envelope","isSampledIn","responseUrl","errorMessage","res","_appId","appId","_checkAndUpdateEndPointUrl","offlineBackOffMultiplier","concat","isOnline","_doBeaconSend","nav","url","batch","plainTextBatch","Blob","type","queued","sendBeacon","_onSuccess","droppedPayload","lp","thePayload","XMLHttpRequest","endPointUrl","open","headerName","onreadystatechange","_xhrReadyStateChange","onerror","send","payloadSize","_doFetchSender","requestHeaders","Headers","batchLength","ignoreResponse","responseHandled","append","init","method","headers","body","keepalive","request","Request","fetch","then","ok","statusText","text","result","parse","itemsAccepted","linearFactor","payload_1","item","_setRetryTime","SlotDelayInSeconds","delayInSeconds","backOffSlot","Math","pow","backOffDelay","floor","random","max","min","retryAfterTimeSpan","retryInterval","timerValue","setTimeout","clearTimeout","_window","XDomainRequest","onload","hostingProtocol","location","protocol","lastIndexOf","replace","_getNotifyMgr","func","sendRequest","manager","disableIKeyValidationFlag","UUID_Regex","regexp","RegExp","test","orig","creator","baseType"],"sources":["/Users/evaristlobo/Documents/GitHub/jhipster-sample-application/client/node_modules/@microsoft/applicationinsights-channel-js/dist-esm/Sender.js"],"sourcesContent":["var _a;\r\nimport { __assign, __extends } from \"tslib\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { BreezeChannelIdentifier, DEFAULT_BREEZE_ENDPOINT, DEFAULT_BREEZE_PATH, DisabledPropertyName, Event, Exception, Metric, PageView, PageViewPerformance, ProcessLegacy, RemoteDependencyData, RequestHeaders, SampleRate, Trace, isInternalApplicationInsightsEndpoint, utlCanUseSessionStorage } from \"@microsoft/applicationinsights-common\";\r\nimport { BaseTelemetryPlugin, _throwInternal, _warnToConsole, arrForEach, createUniqueNamespace, dateNow, dumpObj, getExceptionName, getIEVersion, getJSON, getNavigator, getWindow, isArray, isBeaconsSupported, isFetchSupported, isNullOrUndefined, isXhrSupported, mergeEvtNamespace, objForEachKey, objKeys, useXDomainRequest } from \"@microsoft/applicationinsights-core-js\";\r\nimport { DependencyEnvelopeCreator, EventEnvelopeCreator, ExceptionEnvelopeCreator, MetricEnvelopeCreator, PageViewEnvelopeCreator, PageViewPerformanceEnvelopeCreator, TraceEnvelopeCreator } from \"./EnvelopeCreator\";\r\nimport { createOfflineListener } from \"./Offline\";\r\nimport { ArraySendBuffer, SessionStorageSendBuffer } from \"./SendBuffer\";\r\nimport { Serializer } from \"./Serializer\";\r\nimport { Sample } from \"./TelemetryProcessors/Sample\";\r\nimport { _DYN_BASE_TYPE, _DYN_BATCH_PAYLOADS, _DYN_BUFFER_OVERRIDE, _DYN_CLEAR, _DYN_CLEAR_SENT, _DYN_CONVERT_UNDEFINED, _DYN_COUNT, _DYN_CUSTOM_HEADERS, _DYN_DIAG_LOG, _DYN_DISABLE_INSTRUMENTAT7, _DYN_DISABLE_TELEMETRY, _DYN_DISABLE_XHR, _DYN_EMIT_LINE_DELIMITED_0, _DYN_ENABLE_SESSION_STORA4, _DYN_ENDPOINT_URL, _DYN_ENQUEUE, _DYN_EVENTS_SEND_REQUEST, _DYN_INSTRUMENTATION_KEY, _DYN_IS_BEACON_API_DISABL3, _DYN_IS_ONLINE, _DYN_IS_RETRY_DISABLED, _DYN_ITEMS_ACCEPTED, _DYN_ITEMS_RECEIVED, _DYN_LENGTH, _DYN_MARK_AS_SENT, _DYN_MAX_BATCH_INTERVAL, _DYN_MAX_BATCH_SIZE_IN_BY1, _DYN_NAME_PREFIX, _DYN_ONUNLOAD_DISABLE_BEA2, _DYN_ONUNLOAD_DISABLE_FET5, _DYN_PUSH, _DYN_SAMPLE_RATE, _DYN_SAMPLING_PERCENTAGE, _DYN_SET_REQUEST_HEADER, _DYN_TAGS, _DYN_TRIGGER_SEND, _DYN__BUFFER, _DYN__ON_ERROR, _DYN__ON_PARTIAL_SUCCESS, _DYN__ON_SUCCESS, _DYN__SENDER, _DYN__SENDER_CONFIG, _DYN__XHR_READY_STATE_CHA6 } from \"./__DynamicConstants\";\r\nvar FetchSyncRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)\r\nfunction _getResponseText(xhr) {\r\n    try {\r\n        return xhr.responseText;\r\n    }\r\n    catch (e) {\r\n        // Best effort, as XHR may throw while XDR wont so just ignore\r\n    }\r\n    return null;\r\n}\r\nfunction _getDefaultAppInsightsChannelConfig() {\r\n    var _a;\r\n    var defaultValue;\r\n    var defaultCustomHeaders;\r\n    // set default values\r\n    return _a = {\r\n            endpointUrl: function () { return DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH; }\r\n        },\r\n        _a[_DYN_EMIT_LINE_DELIMITED_0 /* @min:emitLineDelimitedJson */] = function () { return false; },\r\n        _a[_DYN_MAX_BATCH_INTERVAL /* @min:maxBatchInterval */] = function () { return 15000; },\r\n        _a[_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:maxBatchSizeInBytes */] = function () { return 102400; },\r\n        _a[_DYN_DISABLE_TELEMETRY /* @min:disableTelemetry */] = function () { return false; },\r\n        _a[_DYN_ENABLE_SESSION_STORA4 /* @min:enableSessionStorageBuffer */] = function () { return true; },\r\n        _a[_DYN_BUFFER_OVERRIDE /* @min:bufferOverride */] = function () { return false; },\r\n        _a[_DYN_IS_RETRY_DISABLED /* @min:isRetryDisabled */] = function () { return false; },\r\n        _a[_DYN_IS_BEACON_API_DISABL3 /* @min:isBeaconApiDisabled */] = function () { return true; },\r\n        _a[_DYN_DISABLE_XHR /* @min:disableXhr */] = function () { return false; },\r\n        _a[_DYN_ONUNLOAD_DISABLE_FET5 /* @min:onunloadDisableFetch */] = function () { return false; },\r\n        _a[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:onunloadDisableBeacon */] = function () { return false; },\r\n        _a[_DYN_INSTRUMENTATION_KEY /* @min:instrumentationKey */] = function () { return defaultValue; },\r\n        _a[_DYN_NAME_PREFIX /* @min:namePrefix */] = function () { return defaultValue; },\r\n        _a[_DYN_SAMPLING_PERCENTAGE /* @min:samplingPercentage */] = function () { return 100; },\r\n        _a[_DYN_CUSTOM_HEADERS /* @min:customHeaders */] = function () { return defaultCustomHeaders; },\r\n        _a[_DYN_CONVERT_UNDEFINED /* @min:convertUndefined */] = function () { return defaultValue; },\r\n        _a.eventsLimitInMem = function () { return 10000; },\r\n        _a;\r\n}\r\nvar EnvelopeTypeCreator = (_a = {},\r\n    _a[Event.dataType] = EventEnvelopeCreator,\r\n    _a[Trace.dataType] = TraceEnvelopeCreator,\r\n    _a[PageView.dataType] = PageViewEnvelopeCreator,\r\n    _a[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator,\r\n    _a[Exception.dataType] = ExceptionEnvelopeCreator,\r\n    _a[Metric.dataType] = MetricEnvelopeCreator,\r\n    _a[RemoteDependencyData.dataType] = DependencyEnvelopeCreator,\r\n    _a);\r\nvar Sender = /** @class */ (function (_super) {\r\n    __extends(Sender, _super);\r\n    function Sender() {\r\n        var _this = _super.call(this) || this;\r\n        _this.priority = 1001;\r\n        _this.identifier = BreezeChannelIdentifier;\r\n        /**\r\n         * The configuration for this sender instance\r\n         */\r\n        _this._senderConfig = _getDefaultAppInsightsChannelConfig();\r\n        // Don't set the defaults here, set them in the _initDefaults() as this is also called during unload\r\n        var _consecutiveErrors; // How many times in a row a retryable error condition has occurred.\r\n        var _retryAt; // The time to retry at in milliseconds from 1970/01/01 (this makes the timer calculation easy).\r\n        var _lastSend; // The time of the last send operation.\r\n        var _paused; // Flag indicating that the sending should be paused\r\n        var _timeoutHandle; // Handle to the timer for delayed sending of batches of data.\r\n        var _serializer;\r\n        var _stamp_specific_redirects;\r\n        var _headers;\r\n        var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)\r\n        var _fallbackSender; // The sender to use if the payload size is too large\r\n        var _syncUnloadSender; // The identified sender to use for the synchronous unload stage\r\n        var _offlineListener;\r\n        var _evtNamespace;\r\n        dynamicProto(Sender, _this, function (_self, _base) {\r\n            _initDefaults();\r\n            _self.pause = function () {\r\n                _clearScheduledTimer();\r\n                _paused = true;\r\n            };\r\n            _self.resume = function () {\r\n                if (_paused) {\r\n                    _paused = false;\r\n                    _retryAt = null;\r\n                    // flush if we have exceeded the max-size already\r\n                    if (_self._buffer.size() > _self._senderConfig[_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:%2emaxBatchSizeInBytes */]()) {\r\n                        _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 10 /* SendRequestReason.MaxBatchSize */);\r\n                    }\r\n                    _setupTimer();\r\n                }\r\n            };\r\n            _self.flush = function (isAsync, callBack, sendReason) {\r\n                if (isAsync === void 0) { isAsync = true; }\r\n                if (!_paused) {\r\n                    // Clear the normal schedule timer as we are going to try and flush ASAP\r\n                    _clearScheduledTimer();\r\n                    try {\r\n                        _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](isAsync, null, sendReason || 1 /* SendRequestReason.ManualFlush */);\r\n                    }\r\n                    catch (e) {\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 22 /* _eInternalMessageId.FlushFailed */, \"flush failed, telemetry will not be collected: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                    }\r\n                }\r\n            };\r\n            _self.onunloadFlush = function () {\r\n                if (!_paused) {\r\n                    if ((_self._senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */]() === false || _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */]() === false) && isBeaconsSupported()) {\r\n                        try {\r\n                            _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, _doUnloadSend, 2 /* SendRequestReason.Unload */);\r\n                        }\r\n                        catch (e) {\r\n                            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, \"failed to flush with beacon sender on page unload, telemetry will not be collected: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                        }\r\n                    }\r\n                    else {\r\n                        _self.flush();\r\n                    }\r\n                }\r\n            };\r\n            _self.addHeader = function (name, value) {\r\n                _headers[name] = value;\r\n            };\r\n            _self.initialize = function (config, core, extensions, pluginChain) {\r\n                if (_self.isInitialized()) {\r\n                    _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender is already initialized\");\r\n                }\r\n                _base.initialize(config, core, extensions, pluginChain);\r\n                var ctx = _self._getTelCtx();\r\n                var identifier = _self.identifier;\r\n                _serializer = new Serializer(core.logger);\r\n                _consecutiveErrors = 0;\r\n                _retryAt = null;\r\n                _lastSend = 0;\r\n                _self[_DYN__SENDER /* @min:%2e_sender */] = null;\r\n                _stamp_specific_redirects = 0;\r\n                var diagLog = _self[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\r\n                _evtNamespace = mergeEvtNamespace(createUniqueNamespace(\"Sender\"), core.evtNamespace && core.evtNamespace());\r\n                _offlineListener = createOfflineListener(_evtNamespace);\r\n                // TODO v3.x: Change the ISenderConfig to not be function calls\r\n                var defaultConfig = _getDefaultAppInsightsChannelConfig();\r\n                objForEachKey(defaultConfig, function (field, value) {\r\n                    _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][field] = function () {\r\n                        var theValue = ctx.getConfig(identifier, field, value());\r\n                        if (!theValue && field === \"endpointUrl\") {\r\n                            // Use the default value (handles empty string in the configuration)\r\n                            theValue = value();\r\n                        }\r\n                        return theValue;\r\n                    };\r\n                });\r\n                var useSessionStorage = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENABLE_SESSION_STORA4 /* @min:%2eenableSessionStorageBuffer */]() &&\r\n                    !!(_self._senderConfig[_DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */]() || utlCanUseSessionStorage());\r\n                _self[_DYN__BUFFER /* @min:%2e_buffer */] = useSessionStorage\r\n                    ? new SessionStorageSendBuffer(diagLog, _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */])\r\n                    : new ArraySendBuffer(diagLog, _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */]);\r\n                _self._sample = new Sample(_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_SAMPLING_PERCENTAGE /* @min:%2esamplingPercentage */](), diagLog);\r\n                if (!_validateInstrumentationKey(config)) {\r\n                    _throwInternal(diagLog, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, \"Invalid Instrumentation key \" + config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]);\r\n                }\r\n                if (!isInternalApplicationInsightsEndpoint(_self._senderConfig.endpointUrl()) && _self._senderConfig.customHeaders() && _self._senderConfig.customHeaders()[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    arrForEach(_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */](), function (customHeader) {\r\n                        _this.addHeader(customHeader.header, customHeader.value);\r\n                    });\r\n                }\r\n                var senderConfig = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */];\r\n                var sendPostFunc = null;\r\n                if (!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */]() && useXDomainRequest()) {\r\n                    sendPostFunc = _xdrSender; // IE 8 and 9\r\n                }\r\n                else if (!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */]() && isXhrSupported()) {\r\n                    sendPostFunc = _xhrSender;\r\n                }\r\n                if (!sendPostFunc && isFetchSupported()) {\r\n                    sendPostFunc = _fetchSender;\r\n                }\r\n                // always fallback to XHR\r\n                _fallbackSender = sendPostFunc || _xhrSender;\r\n                if (!senderConfig[_DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */]() && isBeaconsSupported()) {\r\n                    // Config is set to always used beacon sending\r\n                    sendPostFunc = _beaconSender;\r\n                }\r\n                _self[_DYN__SENDER /* @min:%2e_sender */] = sendPostFunc || _xhrSender;\r\n                if (!senderConfig[_DYN_ONUNLOAD_DISABLE_FET5 /* @min:%2eonunloadDisableFetch */]() && isFetchSupported(true)) {\r\n                    // Try and use the fetch with keepalive\r\n                    _syncUnloadSender = _fetchKeepAliveSender;\r\n                }\r\n                else if (isBeaconsSupported()) {\r\n                    // Try and use sendBeacon\r\n                    _syncUnloadSender = _beaconSender;\r\n                }\r\n                else if (!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */]() && useXDomainRequest()) {\r\n                    _syncUnloadSender = _xdrSender; // IE 8 and 9\r\n                }\r\n                else if (!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */]() && isXhrSupported()) {\r\n                    _syncUnloadSender = _xhrSender;\r\n                }\r\n                else {\r\n                    _syncUnloadSender = _fallbackSender;\r\n                }\r\n            };\r\n            _self.processTelemetry = function (telemetryItem, itemCtx) {\r\n                itemCtx = _self._getTelCtx(itemCtx);\r\n                var diagLogger = itemCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\r\n                try {\r\n                    // if master off switch is set, don't send any data\r\n                    if (_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_DISABLE_TELEMETRY /* @min:%2edisableTelemetry */]()) {\r\n                        // Do not send/save data\r\n                        return;\r\n                    }\r\n                    // validate input\r\n                    if (!telemetryItem) {\r\n                        _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 7 /* _eInternalMessageId.CannotSendEmptyTelemetry */, \"Cannot send empty telemetry\");\r\n                        return;\r\n                    }\r\n                    // validate event\r\n                    if (telemetryItem.baseData && !telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */]) {\r\n                        _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 70 /* _eInternalMessageId.InvalidEvent */, \"Cannot send telemetry without baseData and baseType\");\r\n                        return;\r\n                    }\r\n                    if (!telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */]) {\r\n                        // Default\r\n                        telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */] = \"EventData\";\r\n                    }\r\n                    // ensure a sender was constructed\r\n                    if (!_self[_DYN__SENDER /* @min:%2e_sender */]) {\r\n                        _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender was not initialized\");\r\n                        return;\r\n                    }\r\n                    // check if this item should be sampled in, else add sampleRate tag\r\n                    if (!_isSampledIn(telemetryItem)) {\r\n                        // Item is sampled out, do not send it\r\n                        _throwInternal(diagLogger, 2 /* eLoggingSeverity.WARNING */, 33 /* _eInternalMessageId.TelemetrySampledAndNotSent */, \"Telemetry item was sampled out and not sent\", { SampleRate: _self._sample[_DYN_SAMPLE_RATE /* @min:%2esampleRate */] });\r\n                        return;\r\n                    }\r\n                    else {\r\n                        telemetryItem[SampleRate] = _self._sample[_DYN_SAMPLE_RATE /* @min:%2esampleRate */];\r\n                    }\r\n                    var convertUndefined = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_CONVERT_UNDEFINED /* @min:%2econvertUndefined */]() || undefined;\r\n                    // construct an envelope that Application Insights endpoint can understand\r\n                    // if ikey of telemetry is provided and not empty, envelope will use this iKey instead of senderConfig iKey\r\n                    var defaultEnvelopeIkey = telemetryItem.iKey || _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]();\r\n                    var aiEnvelope_1 = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, convertUndefined);\r\n                    if (!aiEnvelope_1) {\r\n                        _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 47 /* _eInternalMessageId.CreateEnvelopeError */, \"Unable to create an AppInsights envelope\");\r\n                        return;\r\n                    }\r\n                    var doNotSendItem_1 = false;\r\n                    // this is for running in legacy mode, where customer may already have a custom initializer present\r\n                    if (telemetryItem[_DYN_TAGS /* @min:%2etags */] && telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy]) {\r\n                        arrForEach(telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy], function (callBack) {\r\n                            try {\r\n                                if (callBack && callBack(aiEnvelope_1) === false) {\r\n                                    doNotSendItem_1 = true;\r\n                                    _warnToConsole(diagLogger, \"Telemetry processor check returns false\");\r\n                                }\r\n                            }\r\n                            catch (e) {\r\n                                // log error but dont stop executing rest of the telemetry initializers\r\n                                // doNotSendItem = true;\r\n                                _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 64 /* _eInternalMessageId.TelemetryInitializerFailed */, \"One of telemetry initializers failed, telemetry item will not be sent: \" + getExceptionName(e), { exception: dumpObj(e) }, true);\r\n                            }\r\n                        });\r\n                        delete telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy];\r\n                    }\r\n                    if (doNotSendItem_1) {\r\n                        return; // do not send, no need to execute next plugin\r\n                    }\r\n                    // check if the incoming payload is too large, truncate if necessary\r\n                    var payload = _serializer.serialize(aiEnvelope_1);\r\n                    // flush if we would exceed the max-size limit by adding this item\r\n                    var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\r\n                    var bufferSize = buffer.size();\r\n                    if ((bufferSize + payload[_DYN_LENGTH /* @min:%2elength */]) > _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:%2emaxBatchSizeInBytes */]()) {\r\n                        if (!_offlineListener || _offlineListener[_DYN_IS_ONLINE /* @min:%2eisOnline */]()) { // only trigger send when currently online\r\n                            _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 10 /* SendRequestReason.MaxBatchSize */);\r\n                        }\r\n                    }\r\n                    // enqueue the payload\r\n                    buffer[_DYN_ENQUEUE /* @min:%2eenqueue */](payload);\r\n                    // ensure an invocation timeout is set\r\n                    _setupTimer();\r\n                }\r\n                catch (e) {\r\n                    _throwInternal(diagLogger, 2 /* eLoggingSeverity.WARNING */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, \"Failed adding telemetry to the sender's buffer, some telemetry will be lost: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                }\r\n                // hand off the telemetry item to the next plugin\r\n                _self.processNext(telemetryItem, itemCtx);\r\n            };\r\n            /**\r\n             * xhr state changes\r\n             */\r\n            _self[_DYN__XHR_READY_STATE_CHA6 /* @min:%2e_xhrReadyStateChange */] = function (xhr, payload, countOfItemsInPayload) {\r\n                if (xhr.readyState === 4) {\r\n                    _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, _formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);\r\n                }\r\n            };\r\n            /**\r\n             * Immediately send buffered data\r\n             * @param async {boolean} - Indicates if the events should be sent asynchronously\r\n             * @param forcedSender {SenderFunction} - Indicates the forcedSender, undefined if not passed\r\n             */\r\n            _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */] = function (async, forcedSender, sendReason) {\r\n                if (async === void 0) { async = true; }\r\n                if (!_paused) {\r\n                    try {\r\n                        var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\r\n                        // Send data only if disableTelemetry is false\r\n                        if (!_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_DISABLE_TELEMETRY /* @min:%2edisableTelemetry */]()) {\r\n                            if (buffer[_DYN_COUNT /* @min:%2ecount */]() > 0) {\r\n                                var payload = buffer.getItems();\r\n                                _notifySendRequest(sendReason || 0 /* SendRequestReason.Undefined */, async);\r\n                                // invoke send\r\n                                if (forcedSender) {\r\n                                    forcedSender.call(_this, payload, async);\r\n                                }\r\n                                else {\r\n                                    _self[_DYN__SENDER /* @min:%2e_sender */](payload, async);\r\n                                }\r\n                            }\r\n                            // update lastSend time to enable throttling\r\n                            _lastSend = +new Date;\r\n                        }\r\n                        else {\r\n                            buffer[_DYN_CLEAR /* @min:%2eclear */]();\r\n                        }\r\n                        _clearScheduledTimer();\r\n                    }\r\n                    catch (e) {\r\n                        /* Ignore this error for IE under v10 */\r\n                        var ieVer = getIEVersion();\r\n                        if (!ieVer || ieVer > 9) {\r\n                            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 40 /* _eInternalMessageId.TransmissionFailed */, \"Telemetry transmission failed, some telemetry will be lost: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            _self._doTeardown = function (unloadCtx, unloadState) {\r\n                _self.onunloadFlush();\r\n                _offlineListener.unload();\r\n                _initDefaults();\r\n            };\r\n            /**\r\n             * error handler\r\n             */\r\n            _self[_DYN__ON_ERROR /* @min:%2e_onError */] = function (payload, message, event) {\r\n                _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, \"Failed to send telemetry.\", { message: message });\r\n                _self._buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\r\n            };\r\n            /**\r\n             * partial success handler\r\n             */\r\n            _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */] = function (payload, results) {\r\n                var failed = [];\r\n                var retry = [];\r\n                // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.\r\n                var errors = results.errors.reverse();\r\n                for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\r\n                    var error = errors_1[_i];\r\n                    var extracted = payload.splice(error.index, 1)[0];\r\n                    if (_isRetriable(error.statusCode)) {\r\n                        retry[_DYN_PUSH /* @min:%2epush */](extracted);\r\n                    }\r\n                    else {\r\n                        // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).\r\n                        failed[_DYN_PUSH /* @min:%2epush */](extracted);\r\n                    }\r\n                }\r\n                if (payload[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]);\r\n                }\r\n                if (failed[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    _self[_DYN__ON_ERROR /* @min:%2e_onError */](failed, _formatErrorMessageXhr(null, [\"partial success\", results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */], \"of\", results.itemsReceived].join(\" \")));\r\n                }\r\n                if (retry[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    _resendPayload(retry);\r\n                    _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \"Partial success. \" +\r\n                        \"Delivered: \" + payload[_DYN_LENGTH /* @min:%2elength */] + \", Failed: \" + failed[_DYN_LENGTH /* @min:%2elength */] +\r\n                        \". Will retry to send \" + retry[_DYN_LENGTH /* @min:%2elength */] + \" our of \" + results[_DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] + \" items\");\r\n                }\r\n            };\r\n            /**\r\n             * success handler\r\n             */\r\n            _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */] = function (payload, countOfItemsInPayload) {\r\n                _self._buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\r\n            };\r\n            /**\r\n             * xdr state changes\r\n             */\r\n            _self._xdrOnLoad = function (xdr, payload) {\r\n                var responseText = _getResponseText(xdr);\r\n                if (xdr && (responseText + \"\" === \"200\" || responseText === \"\")) {\r\n                    _consecutiveErrors = 0;\r\n                    _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, 0);\r\n                }\r\n                else {\r\n                    var results = _parseResponse(responseText);\r\n                    if (results && results.itemsReceived && results.itemsReceived > results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]\r\n                        && !_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_RETRY_DISABLED /* @min:%2eisRetryDisabled */]()) {\r\n                        _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, results);\r\n                    }\r\n                    else {\r\n                        _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, _formatErrorMessageXdr(xdr));\r\n                    }\r\n                }\r\n            };\r\n            function _isSampledIn(envelope) {\r\n                return _self._sample.isSampledIn(envelope);\r\n            }\r\n            function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {\r\n                var response = null;\r\n                if (!_self._appId) {\r\n                    response = _parseResponse(res);\r\n                    if (response && response.appId) {\r\n                        _self._appId = response.appId;\r\n                    }\r\n                }\r\n                if ((status < 200 || status >= 300) && status !== 0) {\r\n                    // Update End Point url if permanent redirect or moved permanently\r\n                    // Updates the end point url before retry\r\n                    if (status === 301 || status === 307 || status === 308) {\r\n                        if (!_checkAndUpdateEndPointUrl(responseUrl)) {\r\n                            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (!_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_RETRY_DISABLED /* @min:%2eisRetryDisabled */]() && _isRetriable(status)) {\r\n                        _resendPayload(payload);\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" +\r\n                            \"Response code \" + status + \". Will retry to send \" + payload[_DYN_LENGTH /* @min:%2elength */] + \" items.\");\r\n                    }\r\n                    else {\r\n                        _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\r\n                    }\r\n                }\r\n                else if (_offlineListener && !_offlineListener[_DYN_IS_ONLINE /* @min:%2eisOnline */]()) { // offline\r\n                    // Note: Don't check for status == 0, since adblock gives this code\r\n                    if (!_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_RETRY_DISABLED /* @min:%2eisRetryDisabled */]()) {\r\n                        var offlineBackOffMultiplier = 10; // arbritrary number\r\n                        _resendPayload(payload, offlineBackOffMultiplier);\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". Offline - Response Code: \".concat(status, \". Offline status: \").concat(!_offlineListener.isOnline(), \". Will retry to send \").concat(payload.length, \" items.\"));\r\n                    }\r\n                }\r\n                else {\r\n                    // check if the xhr's responseURL or fetch's response.url is same as endpoint url\r\n                    // TODO after 10 redirects force send telemetry with 'redirect=false' as query parameter.\r\n                    _checkAndUpdateEndPointUrl(responseUrl);\r\n                    if (status === 206) {\r\n                        if (!response) {\r\n                            response = _parseResponse(res);\r\n                        }\r\n                        if (response && !_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_IS_RETRY_DISABLED /* @min:%2eisRetryDisabled */]()) {\r\n                            _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, response);\r\n                        }\r\n                        else {\r\n                            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\r\n                        }\r\n                    }\r\n                    else {\r\n                        _consecutiveErrors = 0;\r\n                        _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, countOfItemsInPayload);\r\n                    }\r\n                }\r\n            }\r\n            function _checkAndUpdateEndPointUrl(responseUrl) {\r\n                // Maximum stamp specific redirects allowed(uncomment this when breeze is ready with not allowing redirects feature)\r\n                if (_stamp_specific_redirects >= 10) {\r\n                    //  _self._senderConfig.endpointUrl = () => Sender._getDefaultAppInsightsChannelConfig().endpointUrl()+\"/?redirect=false\";\r\n                    //  _stamp_specific_redirects = 0;\r\n                    return false;\r\n                }\r\n                if (!isNullOrUndefined(responseUrl) && responseUrl !== \"\") {\r\n                    if (responseUrl !== _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]()) {\r\n                        _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */] = function () { return responseUrl; };\r\n                        ++_stamp_specific_redirects;\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n            function _doUnloadSend(payload, isAsync) {\r\n                if (_syncUnloadSender) {\r\n                    // We are unloading so always call the sender with sync set to false\r\n                    _syncUnloadSender(payload, false);\r\n                }\r\n                else {\r\n                    // Fallback to the previous beacon Sender (which causes a CORB warning on chrome now)\r\n                    _beaconSender(payload, isAsync);\r\n                }\r\n            }\r\n            function _doBeaconSend(payload) {\r\n                var nav = getNavigator();\r\n                var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\r\n                var url = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]();\r\n                var batch = _self._buffer[_DYN_BATCH_PAYLOADS /* @min:%2ebatchPayloads */](payload);\r\n                // Chrome only allows CORS-safelisted values for the sendBeacon data argument\r\n                // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283\r\n                var plainTextBatch = new Blob([batch], { type: \"text/plain;charset=UTF-8\" });\r\n                // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\r\n                var queued = nav.sendBeacon(url, plainTextBatch);\r\n                if (queued) {\r\n                    buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\r\n                    // no response from beaconSender, clear buffer\r\n                    _self._onSuccess(payload, payload[_DYN_LENGTH /* @min:%2elength */]);\r\n                }\r\n                return queued;\r\n            }\r\n            /**\r\n             * Send Beacon API request\r\n             * @param payload {string} - The data payload to be sent.\r\n             * @param isAsync {boolean} - not used\r\n             * Note: Beacon API does not support custom headers and we are not able to get\r\n             * appId from the backend for the correct correlation.\r\n             */\r\n            function _beaconSender(payload, isAsync) {\r\n                if (isArray(payload) && payload[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\r\n                    if (!_doBeaconSend(payload)) {\r\n                        // Failed to send entire payload so try and split data and try to send as much events as possible\r\n                        var droppedPayload = [];\r\n                        for (var lp = 0; lp < payload[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n                            var thePayload = payload[lp];\r\n                            if (!_doBeaconSend([thePayload])) {\r\n                                // Can't send anymore, so split the batch and drop the rest\r\n                                droppedPayload[_DYN_PUSH /* @min:%2epush */](thePayload);\r\n                            }\r\n                        }\r\n                        if (droppedPayload[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                            _fallbackSender && _fallbackSender(droppedPayload, true);\r\n                            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with normal sender.\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            /**\r\n             * Send XMLHttpRequest\r\n             * @param payload {string} - The data payload to be sent.\r\n             * @param isAsync {boolean} - Indicates if the request should be sent asynchronously\r\n             */\r\n            function _xhrSender(payload, isAsync) {\r\n                var xhr = new XMLHttpRequest();\r\n                var endPointUrl = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]();\r\n                try {\r\n                    xhr[DisabledPropertyName] = true;\r\n                }\r\n                catch (e) {\r\n                    // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would\r\n                    // cause the request to fail and we no telemetry would be sent\r\n                }\r\n                xhr.open(\"POST\", endPointUrl, isAsync);\r\n                xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](\"Content-type\", \"application/json\");\r\n                // append Sdk-Context request header only in case of breeze endpoint\r\n                if (isInternalApplicationInsightsEndpoint(endPointUrl)) {\r\n                    xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](RequestHeaders[6 /* eRequestHeaders.sdkContextHeader */], RequestHeaders[7 /* eRequestHeaders.sdkContextHeaderAppIdRequest */]);\r\n                }\r\n                arrForEach(objKeys(_headers), function (headerName) {\r\n                    xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](headerName, _headers[headerName]);\r\n                });\r\n                xhr.onreadystatechange = function () { return _self._xhrReadyStateChange(xhr, payload, payload[_DYN_LENGTH /* @min:%2elength */]); };\r\n                xhr.onerror = function (event) { return _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, _formatErrorMessageXhr(xhr), event); };\r\n                // compose an array of payloads\r\n                var batch = _self._buffer[_DYN_BATCH_PAYLOADS /* @min:%2ebatchPayloads */](payload);\r\n                xhr.send(batch);\r\n                _self._buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\r\n            }\r\n            function _fetchKeepAliveSender(payload, isAsync) {\r\n                if (isArray(payload)) {\r\n                    var payloadSize = payload[_DYN_LENGTH /* @min:%2elength */];\r\n                    for (var lp = 0; lp < payload[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n                        payloadSize += payload[lp][_DYN_LENGTH /* @min:%2elength */];\r\n                    }\r\n                    if ((_syncFetchPayload + payloadSize) <= FetchSyncRequestSizeLimitBytes) {\r\n                        _doFetchSender(payload, false);\r\n                    }\r\n                    else if (isBeaconsSupported()) {\r\n                        // Fallback to beacon sender as we at least get told which events can't be scheduled\r\n                        _beaconSender(payload, isAsync);\r\n                    }\r\n                    else {\r\n                        // Payload is going to be too big so just try and send via XHR\r\n                        _fallbackSender && _fallbackSender(payload, true);\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with xhrSender.\");\r\n                    }\r\n                }\r\n            }\r\n            /**\r\n             * Send fetch API request\r\n             * @param payload {string} - The data payload to be sent.\r\n             * @param isAsync {boolean} - not used\r\n             */\r\n            function _fetchSender(payload, isAsync) {\r\n                _doFetchSender(payload, true);\r\n            }\r\n            /**\r\n             * Send fetch API request\r\n             * @param payload {string} - The data payload to be sent.\r\n             * @param isAsync {boolean} - For fetch this identifies whether we are \"unloading\" (false) or a normal request\r\n             */\r\n            function _doFetchSender(payload, isAsync) {\r\n                var _a;\r\n                var endPointUrl = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]();\r\n                var batch = _self._buffer[_DYN_BATCH_PAYLOADS /* @min:%2ebatchPayloads */](payload);\r\n                var plainTextBatch = new Blob([batch], { type: \"application/json\" });\r\n                var requestHeaders = new Headers();\r\n                var batchLength = batch[_DYN_LENGTH /* @min:%2elength */];\r\n                var ignoreResponse = false;\r\n                var responseHandled = false;\r\n                // append Sdk-Context request header only in case of breeze endpoint\r\n                if (isInternalApplicationInsightsEndpoint(endPointUrl)) {\r\n                    requestHeaders.append(RequestHeaders[6 /* eRequestHeaders.sdkContextHeader */], RequestHeaders[7 /* eRequestHeaders.sdkContextHeaderAppIdRequest */]);\r\n                }\r\n                arrForEach(objKeys(_headers), function (headerName) {\r\n                    requestHeaders.append(headerName, _headers[headerName]);\r\n                });\r\n                var init = (_a = {\r\n                        method: \"POST\",\r\n                        headers: requestHeaders,\r\n                        body: plainTextBatch\r\n                    },\r\n                    _a[DisabledPropertyName] = true // Mark so we don't attempt to track this request\r\n                ,\r\n                    _a);\r\n                if (!isAsync) {\r\n                    init.keepalive = true;\r\n                    // As a sync request (during unload), it is unlikely that we will get a chance to process the response so\r\n                    // just like beacon send assume that the events have been accepted and processed\r\n                    ignoreResponse = true;\r\n                    _syncFetchPayload += batchLength;\r\n                }\r\n                var request = new Request(endPointUrl, init);\r\n                try {\r\n                    // Also try and tag the request (just in case the value in init is not copied over)\r\n                    request[DisabledPropertyName] = true;\r\n                }\r\n                catch (e) {\r\n                    // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would\r\n                    // cause the request to fail and we no telemetry would be sent\r\n                }\r\n                _self._buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\r\n                try {\r\n                    fetch(request).then(function (response) {\r\n                        if (!isAsync) {\r\n                            _syncFetchPayload -= batchLength;\r\n                            batchLength = 0;\r\n                        }\r\n                        if (!responseHandled) {\r\n                            responseHandled = true;\r\n                            /**\r\n                             * The Promise returned from fetch() wonâ€™t reject on HTTP error status even if the response is an HTTP 404 or 500.\r\n                             * Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure\r\n                             * or if anything prevented the request from completing.\r\n                             */\r\n                            if (!response.ok) {\r\n                                _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, response.statusText);\r\n                            }\r\n                            else {\r\n                                response.text().then(function (text) {\r\n                                    _checkResponsStatus(response.status, payload, response.url, payload[_DYN_LENGTH /* @min:%2elength */], response.statusText, text);\r\n                                });\r\n                            }\r\n                        }\r\n                    })[\"catch\"](function (error) {\r\n                        if (!isAsync) {\r\n                            _syncFetchPayload -= batchLength;\r\n                            batchLength = 0;\r\n                        }\r\n                        if (!responseHandled) {\r\n                            responseHandled = true;\r\n                            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, error.message);\r\n                        }\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    if (!responseHandled) {\r\n                        _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, dumpObj(e));\r\n                    }\r\n                }\r\n                if (ignoreResponse && !responseHandled) {\r\n                    // Assume success during unload processing as we most likely won't get the response\r\n                    responseHandled = true;\r\n                    _self._onSuccess(payload, payload[_DYN_LENGTH /* @min:%2elength */]);\r\n                }\r\n            }\r\n            /**\r\n             * Parses the response from the backend.\r\n             * @param response - XMLHttpRequest or XDomainRequest response\r\n             */\r\n            function _parseResponse(response) {\r\n                try {\r\n                    if (response && response !== \"\") {\r\n                        var result = getJSON().parse(response);\r\n                        if (result && result.itemsReceived && result.itemsReceived >= result[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */] &&\r\n                            result.itemsReceived - result.itemsAccepted === result.errors[_DYN_LENGTH /* @min:%2elength */]) {\r\n                            return result;\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 43 /* _eInternalMessageId.InvalidBackendResponse */, \"Cannot parse the response. \" + getExceptionName(e), {\r\n                        response: response\r\n                    });\r\n                }\r\n                return null;\r\n            }\r\n            /**\r\n             * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).\r\n             * @param payload\r\n             */\r\n            function _resendPayload(payload, linearFactor) {\r\n                if (linearFactor === void 0) { linearFactor = 1; }\r\n                if (!payload || payload[_DYN_LENGTH /* @min:%2elength */] === 0) {\r\n                    return;\r\n                }\r\n                var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\r\n                buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\r\n                _consecutiveErrors++;\r\n                for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {\r\n                    var item = payload_1[_i];\r\n                    buffer[_DYN_ENQUEUE /* @min:%2eenqueue */](item);\r\n                }\r\n                // setup timer\r\n                _setRetryTime(linearFactor);\r\n                _setupTimer();\r\n            }\r\n            /**\r\n             * Calculates the time to wait before retrying in case of an error based on\r\n             * http://en.wikipedia.org/wiki/Exponential_backoff\r\n             */\r\n            function _setRetryTime(linearFactor) {\r\n                var SlotDelayInSeconds = 10;\r\n                var delayInSeconds;\r\n                if (_consecutiveErrors <= 1) {\r\n                    delayInSeconds = SlotDelayInSeconds;\r\n                }\r\n                else {\r\n                    var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;\r\n                    // tslint:disable-next-line:insecure-random\r\n                    var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;\r\n                    backOffDelay = linearFactor * backOffDelay;\r\n                    delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);\r\n                }\r\n                // TODO: Log the backoff time like the C# version does.\r\n                var retryAfterTimeSpan = dateNow() + (delayInSeconds * 1000);\r\n                // TODO: Log the retry at time like the C# version does.\r\n                _retryAt = retryAfterTimeSpan;\r\n            }\r\n            /**\r\n             * Sets up the timer which triggers actually sending the data.\r\n             */\r\n            function _setupTimer() {\r\n                if (!_timeoutHandle && !_paused) {\r\n                    var retryInterval = _retryAt ? Math.max(0, _retryAt - dateNow()) : 0;\r\n                    var timerValue = Math.max(_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_MAX_BATCH_INTERVAL /* @min:%2emaxBatchInterval */](), retryInterval);\r\n                    _timeoutHandle = setTimeout(function () {\r\n                        _timeoutHandle = null;\r\n                        _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 1 /* SendRequestReason.NormalSchedule */);\r\n                    }, timerValue);\r\n                }\r\n            }\r\n            function _clearScheduledTimer() {\r\n                clearTimeout(_timeoutHandle);\r\n                _timeoutHandle = null;\r\n                _retryAt = null;\r\n            }\r\n            /**\r\n             * Checks if the SDK should resend the payload after receiving this status code from the backend.\r\n             * @param statusCode\r\n             */\r\n            function _isRetriable(statusCode) {\r\n                return statusCode === 401 // Unauthorized\r\n                    || statusCode === 403 // Forbidden\r\n                    || statusCode === 408 // Timeout\r\n                    || statusCode === 429 // Too many requests.\r\n                    || statusCode === 500 // Internal server error.\r\n                    || statusCode === 502 // Bad Gateway.\r\n                    || statusCode === 503 // Service unavailable.\r\n                    || statusCode === 504; // Gateway timeout.\r\n            }\r\n            function _formatErrorMessageXhr(xhr, message) {\r\n                if (xhr) {\r\n                    return \"XMLHttpRequest,Status:\" + xhr.status + \",Response:\" + _getResponseText(xhr) || xhr.response || \"\";\r\n                }\r\n                return message;\r\n            }\r\n            /**\r\n             * Send XDomainRequest\r\n             * @param payload {string} - The data payload to be sent.\r\n             * @param isAsync {boolean} - Indicates if the request should be sent asynchronously\r\n             *\r\n             * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added\r\n             * to maintain consistency with the xhrSender's contract\r\n             * Note: XDomainRequest does not support custom headers and we are not able to get\r\n             * appId from the backend for the correct correlation.\r\n             */\r\n            function _xdrSender(payload, isAsync) {\r\n                var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\r\n                var _window = getWindow();\r\n                var xdr = new XDomainRequest();\r\n                xdr.onload = function () { return _self._xdrOnLoad(xdr, payload); };\r\n                xdr.onerror = function (event) { return _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, _formatErrorMessageXdr(xdr), event); };\r\n                // XDomainRequest requires the same protocol as the hosting page.\r\n                // If the protocol doesn't match, we can't send the telemetry :(.\r\n                var hostingProtocol = _window && _window.location && _window.location.protocol || \"\";\r\n                if (_self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]().lastIndexOf(hostingProtocol, 0) !== 0) {\r\n                    _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" +\r\n                        \"Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.\");\r\n                    buffer[_DYN_CLEAR /* @min:%2eclear */]();\r\n                    return;\r\n                }\r\n                var endpointUrl = _self[_DYN__SENDER_CONFIG /* @min:%2e_senderConfig */][_DYN_ENDPOINT_URL /* @min:%2eendpointUrl */]().replace(/^(https?:)/, \"\");\r\n                xdr.open(\"POST\", endpointUrl);\r\n                // compose an array of payloads\r\n                var batch = buffer[_DYN_BATCH_PAYLOADS /* @min:%2ebatchPayloads */](payload);\r\n                xdr.send(batch);\r\n                buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\r\n            }\r\n            function _formatErrorMessageXdr(xdr, message) {\r\n                if (xdr) {\r\n                    return \"XDomainRequest,Response:\" + _getResponseText(xdr) || \"\";\r\n                }\r\n                return message;\r\n            }\r\n            // Using function lookups for backward compatibility as the getNotifyMgr() did not exist until after v2.5.6\r\n            function _getNotifyMgr() {\r\n                var func = \"getNotifyMgr\";\r\n                if (_self.core[func]) {\r\n                    return _self.core[func]();\r\n                }\r\n                // using _self.core['_notificationManager'] for backward compatibility\r\n                return _self.core[\"_notificationManager\"];\r\n            }\r\n            function _notifySendRequest(sendRequest, isAsync) {\r\n                var manager = _getNotifyMgr();\r\n                if (manager && manager[_DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */]) {\r\n                    try {\r\n                        manager[_DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendRequest, isAsync);\r\n                    }\r\n                    catch (e) {\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, \"send request notification failed: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                    }\r\n                }\r\n            }\r\n            /**\r\n             * Validate UUID Format\r\n             * Specs taken from https://tools.ietf.org/html/rfc4122 and breeze repo\r\n             */\r\n            function _validateInstrumentationKey(config) {\r\n                var disableIKeyValidationFlag = isNullOrUndefined(config[_DYN_DISABLE_INSTRUMENTAT7 /* @min:%2edisableInstrumentationKeyValidation */]) ? false : config[_DYN_DISABLE_INSTRUMENTAT7 /* @min:%2edisableInstrumentationKeyValidation */];\r\n                if (disableIKeyValidationFlag) {\r\n                    return true;\r\n                }\r\n                var UUID_Regex = \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\";\r\n                var regexp = new RegExp(UUID_Regex);\r\n                return regexp.test(config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */]);\r\n            }\r\n            function _initDefaults() {\r\n                _self[_DYN__SENDER /* @min:%2e_sender */] = null;\r\n                _self[_DYN__BUFFER /* @min:%2e_buffer */] = null;\r\n                _self._appId = null;\r\n                _self._sample = null;\r\n                _headers = {};\r\n                _offlineListener = null;\r\n                _consecutiveErrors = 0;\r\n                _retryAt = null;\r\n                _lastSend = null;\r\n                _paused = false;\r\n                _timeoutHandle = null;\r\n                _serializer = null;\r\n                _stamp_specific_redirects = 0;\r\n                _syncFetchPayload = 0;\r\n                _fallbackSender = null;\r\n                _syncUnloadSender = null;\r\n                _evtNamespace = null;\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n    Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {\r\n        var envelope;\r\n        if (iKey !== orig.iKey && !isNullOrUndefined(iKey)) {\r\n            envelope = __assign(__assign({}, orig), { iKey: iKey });\r\n        }\r\n        else {\r\n            envelope = orig;\r\n        }\r\n        var creator = EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator;\r\n        return creator(logger, envelope, convertUndefined);\r\n    };\r\n    /**\r\n     * Pause the sending (transmission) of events, this will cause all events to be batched only until the maximum limits are\r\n     * hit at which point new events are dropped. Will also cause events to NOT be sent during page unload, so if Session storage\r\n     * is disabled events will be lost.\r\n     * SessionStorage Limit is 2000 events, In-Memory (Array) Storage is 10,000 events (can be configured via the eventsLimitInMem).\r\n     */\r\n    Sender.prototype.pause = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Resume the sending (transmission) of events, this will restart the timer and any batched events will be sent using the normal\r\n     * send interval.\r\n     */\r\n    Sender.prototype.resume = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Flush the batched events immediately (not synchronously).\r\n     * Will not flush if the Sender has been paused.\r\n     */\r\n    Sender.prototype.flush = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Flush the batched events synchronously (if possible -- based on configuration).\r\n     * Will not flush if the Send has been paused.\r\n     */\r\n    Sender.prototype.onunloadFlush = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.initialize = function (config, core, extensions, pluginChain) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.processTelemetry = function (telemetryItem, itemCtx) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * xhr state changes\r\n     */\r\n    Sender.prototype._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Immediately send buffered data\r\n     * @param async {boolean} - Indicates if the events should be sent asynchronously\r\n     * @param forcedSender {SenderFunction} - Indicates the forcedSender, undefined if not passed\r\n     */\r\n    Sender.prototype.triggerSend = function (async, forcedSender, sendReason) {\r\n        if (async === void 0) { async = true; }\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * error handler\r\n     */\r\n    Sender.prototype._onError = function (payload, message, event) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * partial success handler\r\n     */\r\n    Sender.prototype._onPartialSuccess = function (payload, results) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * success handler\r\n     */\r\n    Sender.prototype._onSuccess = function (payload, countOfItemsInPayload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * xdr state changes\r\n     */\r\n    Sender.prototype._xdrOnLoad = function (xdr, payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Add header to request\r\n     * @param name   - Header name.\r\n     * @param value  - Header value.\r\n     */\r\n    Sender.prototype.addHeader = function (name, value) {\r\n        // @DynamicProtoStub - DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return Sender;\r\n}(BaseTelemetryPlugin));\r\nexport { Sender };\r\n//# sourceMappingURL=Sender.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}