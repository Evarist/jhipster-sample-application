{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 2.8.12\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nimport { _DYN_CALL, _DYN_CONFIG, _DYN_CREATE_NEW, _DYN_DIAG_LOG, _DYN_GET_NEXT, _DYN_GET_PLUGIN, _DYN_IDENTIFIER, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_LOGGER, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_SET_NEXT_PLUGIN, _DYN_TEARDOWN, _DYN_UPDATE } from \"../__DynamicConstants\";\nimport { _throwInternal, safeGetLogger } from \"./DiagnosticLogger\";\nimport { dumpObj } from \"./EnvUtils\";\nimport { arrForEach, isArray, isFunction, isNullOrUndefined, isObject, isUndefined, objExtend, objForEachKey, objFreeze, objKeys, proxyFunctions } from \"./HelperFuncs\";\nimport { STR_CORE, STR_DISABLED, STR_EMPTY, STR_EXTENSION_CONFIG, STR_PRIORITY, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\nimport { doPerf } from \"./PerfManager\";\nimport { _getPluginState } from \"./TelemetryHelpers\";\nvar strTelemetryPluginChain = \"TelemetryPluginChain\";\nvar strHasRunFlags = \"_hasRun\";\nvar strGetTelCtx = \"_getTelCtx\";\nvar _chainId = 0;\nfunction _getNextProxyStart(proxy, core, startAt) {\n  while (proxy) {\n    if (proxy[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]() === startAt) {\n      return proxy;\n    }\n    proxy = proxy[_DYN_GET_NEXT /* @min:%2egetNext */]();\n  }\n  // This wasn't found in the existing chain so create an isolated one with just this plugin\n  return createTelemetryProxyChain([startAt], core[_DYN_CONFIG /* @min:%2econfig */] || {}, core);\n}\n/**\r\n * @ignore\r\n * @param telemetryChain\r\n * @param config\r\n * @param core\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n * @returns\r\n */\nfunction _createInternalContext(telemetryChain, config, _core, startAt) {\n  // We have a special case where we want to start execution from this specific plugin\n  // or we simply reuse the existing telemetry plugin chain (normal execution case)\n  var _nextProxy = null; // By Default set as no next plugin\n  var _onComplete = [];\n  if (startAt !== null) {\n    // There is no next element (null) vs not defined (undefined) so use the full chain\n    _nextProxy = startAt ? _getNextProxyStart(telemetryChain, _core, startAt) : telemetryChain;\n  }\n  var context = {\n    _next: _moveNext,\n    ctx: {\n      core: function core() {\n        return _core;\n      },\n      diagLog: function diagLog() {\n        return safeGetLogger(_core, config);\n      },\n      getCfg: function getCfg() {\n        return config;\n      },\n      getExtCfg: _getExtCfg,\n      getConfig: _getConfig,\n      hasNext: function hasNext() {\n        return !!_nextProxy;\n      },\n      getNext: function getNext() {\n        return _nextProxy;\n      },\n      setNext: function setNext(nextPlugin) {\n        _nextProxy = nextPlugin;\n      },\n      iterate: _iterateChain,\n      onComplete: _addOnComplete\n    }\n  };\n  function _addOnComplete(onComplete, that) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    }\n    if (onComplete) {\n      _onComplete[_DYN_PUSH /* @min:%2epush */]({\n        func: onComplete,\n        self: !isUndefined(that) ? that : context.ctx,\n        args: args\n      });\n    }\n  }\n  function _moveNext() {\n    var nextProxy = _nextProxy;\n    // Automatically move to the next plugin\n    _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT /* @min:%2egetNext */]() : null;\n    if (!nextProxy) {\n      var onComplete = _onComplete;\n      if (onComplete && onComplete[_DYN_LENGTH /* @min:%2elength */] > 0) {\n        arrForEach(onComplete, function (completeDetails) {\n          try {\n            completeDetails.func[_DYN_CALL /* @min:%2ecall */](completeDetails.self, completeDetails.args);\n          } catch (e) {\n            _throwInternal(_core[_DYN_LOGGER /* @min:%2elogger */], 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, \"Unexpected Exception during onComplete - \" + dumpObj(e));\n          }\n        });\n        _onComplete = [];\n      }\n    }\n    return nextProxy;\n  }\n  function _getExtCfg(identifier, defaultValue, mergeDefault) {\n    if (defaultValue === void 0) {\n      defaultValue = {};\n    }\n    if (mergeDefault === void 0) {\n      mergeDefault = 0 /* GetExtCfgMergeType.None */;\n    }\n    var theConfig;\n    if (config) {\n      var extConfig = config[STR_EXTENSION_CONFIG /* @min:%2eextensionConfig */];\n      if (extConfig && identifier) {\n        theConfig = extConfig[identifier];\n      }\n    }\n    if (!theConfig) {\n      // Just use the defaults\n      theConfig = defaultValue;\n    } else if (isObject(defaultValue)) {\n      if (mergeDefault !== 0 /* GetExtCfgMergeType.None */) {\n        // Merge the defaults and configured values\n        var newConfig_1 = objExtend(true, defaultValue, theConfig);\n        if (config && mergeDefault === 2 /* GetExtCfgMergeType.MergeDefaultFromRootOrDefault */) {\n          // Enumerate over the defaultValues and if not already populated attempt to\n          // find a value from the root config\n          objForEachKey(defaultValue, function (field) {\n            // for each unspecified field, set the default value\n            if (isNullOrUndefined(newConfig_1[field])) {\n              var cfgValue = config[field];\n              if (!isNullOrUndefined(cfgValue)) {\n                newConfig_1[field] = cfgValue;\n              }\n            }\n          });\n        }\n        theConfig = newConfig_1;\n      }\n    }\n    return theConfig;\n  }\n  function _getConfig(identifier, field, defaultValue) {\n    if (defaultValue === void 0) {\n      defaultValue = false;\n    }\n    var theValue;\n    var extConfig = _getExtCfg(identifier, null);\n    if (extConfig && !isNullOrUndefined(extConfig[field])) {\n      theValue = extConfig[field];\n    } else if (config && !isNullOrUndefined(config[field])) {\n      theValue = config[field];\n    }\n    return !isNullOrUndefined(theValue) ? theValue : defaultValue;\n  }\n  function _iterateChain(cb) {\n    // Keep processing until we reach the end of the chain\n    var nextPlugin;\n    while (!!(nextPlugin = context._next())) {\n      var plugin = nextPlugin[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]();\n      if (plugin) {\n        // callback with the current on\n        cb(plugin);\n      }\n    }\n  }\n  return context;\n}\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\nexport function createProcessTelemetryContext(telemetryChain, config, core, startAt) {\n  var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\n  var context = internalContext.ctx;\n  function _processNext(env) {\n    var nextPlugin = internalContext._next();\n    // Run the next plugin which will call \"processNext()\"\n    nextPlugin && nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, context);\n    return !nextPlugin;\n  }\n  function _createNew(plugins, startAt) {\n    if (plugins === void 0) {\n      plugins = null;\n    }\n    if (isArray(plugins)) {\n      plugins = createTelemetryProxyChain(plugins, config, core, startAt);\n    }\n    return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), config, core, startAt);\n  }\n  context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\n  context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\n  return context;\n}\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain for handling the unloading of the chain\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\nexport function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {\n  var config = core[_DYN_CONFIG /* @min:%2econfig */] || {};\n  var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\n  var context = internalContext.ctx;\n  function _processNext(unloadState) {\n    var nextPlugin = internalContext._next();\n    nextPlugin && nextPlugin.unload(context, unloadState);\n    return !nextPlugin;\n  }\n  function _createNew(plugins, startAt) {\n    if (plugins === void 0) {\n      plugins = null;\n    }\n    if (isArray(plugins)) {\n      plugins = createTelemetryProxyChain(plugins, config, core, startAt);\n    }\n    return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);\n  }\n  context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\n  context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\n  return context;\n}\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain for updating the configuration\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\nexport function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {\n  var config = core[_DYN_CONFIG /* @min:%2econfig */] || {};\n  var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\n  var context = internalContext.ctx;\n  function _processNext(updateState) {\n    return context.iterate(function (plugin) {\n      if (isFunction(plugin[_DYN_UPDATE /* @min:%2eupdate */])) {\n        plugin[_DYN_UPDATE /* @min:%2eupdate */](context, updateState);\n      }\n    });\n  }\n  function _createNew(plugins, startAt) {\n    if (plugins === void 0) {\n      plugins = null;\n    }\n    if (isArray(plugins)) {\n      plugins = createTelemetryProxyChain(plugins, config, core, startAt);\n    }\n    return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);\n  }\n  context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\n  context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\n  return context;\n}\n/**\r\n * Creates an execution chain from the array of plugins\r\n * @param plugins - The array of plugins that will be executed in this order\r\n * @param defItemCtx - The default execution context to use when no telemetry context is passed to processTelemetry(), this\r\n * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error\r\n * reporting (hasRun) when errors occur.\r\n */\nexport function createTelemetryProxyChain(plugins, config, core, startAt) {\n  var firstProxy = null;\n  var add = startAt ? false : true;\n  if (isArray(plugins) && plugins[_DYN_LENGTH /* @min:%2elength */] > 0) {\n    // Create the proxies and wire up the next plugin chain\n    var lastProxy_1 = null;\n    arrForEach(plugins, function (thePlugin) {\n      if (!add && startAt === thePlugin) {\n        add = true;\n      }\n      if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\n        // Only add plugins that are processors\n        var newProxy = createTelemetryPluginProxy(thePlugin, config, core);\n        if (!firstProxy) {\n          firstProxy = newProxy;\n        }\n        if (lastProxy_1) {\n          // Set this new proxy as the next for the previous one\n          lastProxy_1._setNext(newProxy);\n        }\n        lastProxy_1 = newProxy;\n      }\n    });\n  }\n  if (startAt && !firstProxy) {\n    // Special case where the \"startAt\" was not in the original list of plugins\n    return createTelemetryProxyChain([startAt], config, core);\n  }\n  return firstProxy;\n}\n/**\r\n * Create the processing telemetry proxy instance, the proxy is used to abstract the current plugin to allow monitoring and\r\n * execution plugins while passing around the dynamic execution state (IProcessTelemetryContext), the proxy instance no longer\r\n * contains any execution state and can be reused between requests (this was not the case for 2.7.2 and earlier with the\r\n * TelemetryPluginChain class).\r\n * @param plugin - The plugin instance to proxy\r\n * @param config - The default execution context to use when no telemetry context is passed to processTelemetry(), this\r\n * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error\r\n * reporting (hasRun) when errors occur.\r\n * @returns\r\n */\nexport function createTelemetryPluginProxy(plugin, config, core) {\n  var nextProxy = null;\n  var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]);\n  var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */]);\n  var chainId;\n  if (plugin) {\n    chainId = plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"-\" + plugin[STR_PRIORITY /* @min:%2epriority */] + \"-\" + _chainId++;\n  } else {\n    chainId = \"Unknown-0-\" + _chainId++;\n  }\n  var proxyChain = {\n    getPlugin: function getPlugin() {\n      return plugin;\n    },\n    getNext: function getNext() {\n      return nextProxy;\n    },\n    processTelemetry: _processTelemetry,\n    unload: _unloadPlugin,\n    update: _updatePlugin,\n    _id: chainId,\n    _setNext: function _setNext(nextPlugin) {\n      nextProxy = nextPlugin;\n    }\n  };\n  function _getTelCtx() {\n    var itemCtx;\n    // Looks like a plugin didn't pass the (optional) context, so create a new one\n    if (plugin && isFunction(plugin[strGetTelCtx])) {\n      // This plugin extends from the BaseTelemetryPlugin so lets use it\n      itemCtx = plugin[strGetTelCtx]();\n    }\n    if (!itemCtx) {\n      // Create a temporary one\n      itemCtx = createProcessTelemetryContext(proxyChain, config, core);\n    }\n    return itemCtx;\n  }\n  function _processChain(itemCtx, processPluginFn, name, details, isAsync) {\n    var hasRun = false;\n    var identifier = plugin ? plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] : strTelemetryPluginChain;\n    var hasRunContext = itemCtx[strHasRunFlags];\n    if (!hasRunContext) {\n      // Assign and populate\n      hasRunContext = itemCtx[strHasRunFlags] = {};\n    }\n    // Ensure that we keep the context in sync\n    itemCtx.setNext(nextProxy);\n    if (plugin) {\n      doPerf(itemCtx[STR_CORE /* @min:%2ecore */](), function () {\n        return identifier + \":\" + name;\n      }, function () {\n        // Mark this component as having run\n        hasRunContext[chainId] = true;\n        try {\n          // Set a flag on the next plugin so we know if it was attempted to be executed\n          var nextId = nextProxy ? nextProxy._id : STR_EMPTY;\n          if (nextId) {\n            hasRunContext[nextId] = false;\n          }\n          hasRun = processPluginFn(itemCtx);\n        } catch (error) {\n          var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;\n          if (hasNextRun) {\n            // The next plugin after us has already run so set this one as complete\n            hasRun = true;\n          }\n          if (!nextProxy || !hasNextRun) {\n            // Either we have no next plugin or the current one did not attempt to call the next plugin\n            // Which means the current one is the root of the failure so log/report this failure\n            _throwInternal(itemCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 73 /* _eInternalMessageId.PluginException */, \"Plugin [\" + identifier + \"] failed during \" + name + \" - \" + dumpObj(error) + \", run flags: \" + dumpObj(hasRunContext));\n          }\n        }\n      }, details, isAsync);\n    }\n    return hasRun;\n  }\n  function _processTelemetry(env, itemCtx) {\n    itemCtx = itemCtx || _getTelCtx();\n    function _callProcessTelemetry(itemCtx) {\n      if (!plugin || !hasProcessTelemetry) {\n        return false;\n      }\n      var pluginState = _getPluginState(plugin);\n      if (pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] || pluginState[STR_DISABLED]) {\n        return false;\n      }\n      // Ensure that we keep the context in sync (for processNext()), just in case a plugin\n      // doesn't calls processTelemetry() instead of itemContext.processNext() or some\n      // other form of error occurred\n      if (hasSetNext) {\n        // Backward compatibility setting the next plugin on the instance\n        plugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](nextProxy);\n      }\n      plugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, itemCtx);\n      // Process Telemetry is expected to call itemCtx.processNext() or nextPlugin.processTelemetry()\n      return true;\n    }\n    if (!_processChain(itemCtx, _callProcessTelemetry, \"processTelemetry\", function () {\n      return {\n        item: env\n      };\n    }, !env.sync)) {\n      // The underlying plugin is either not defined, not enabled or does not have a processTelemetry implementation\n      // so we still want the next plugin to be executed.\n      itemCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);\n    }\n  }\n  function _unloadPlugin(unloadCtx, unloadState) {\n    function _callTeardown() {\n      // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().\n      var hasRun = false;\n      if (plugin) {\n        var pluginState = _getPluginState(plugin);\n        var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE /* @min:%2ecore */];\n        // Only teardown the plugin if it was initialized by the current core (i.e. It's not a shared plugin)\n        if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */]) {\n          // Handle plugins that don't extend from the BaseTelemetryPlugin\n          pluginState[STR_CORE /* @min:%2ecore */] = null;\n          pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] = true;\n          pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = false;\n          if (plugin[_DYN_TEARDOWN /* @min:%2eteardown */] && plugin[_DYN_TEARDOWN /* @min:%2eteardown */](unloadCtx, unloadState) === true) {\n            // plugin told us that it was going to (or has) call unloadCtx.processNext()\n            hasRun = true;\n          }\n        }\n      }\n      return hasRun;\n    }\n    if (!_processChain(unloadCtx, _callTeardown, \"unload\", function () {}, unloadState[_DYN_IS_ASYNC /* @min:%2eisAsync */])) {\n      // Only called if we hasRun was not true\n      unloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\n    }\n  }\n  function _updatePlugin(updateCtx, updateState) {\n    function _callUpdate() {\n      // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().\n      var hasRun = false;\n      if (plugin) {\n        var pluginState = _getPluginState(plugin);\n        var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE /* @min:%2ecore */];\n        // Only update the plugin if it was initialized by the current core (i.e. It's not a shared plugin)\n        if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */]) {\n          if (plugin[_DYN_UPDATE /* @min:%2eupdate */] && plugin[_DYN_UPDATE /* @min:%2eupdate */](updateCtx, updateState) === true) {\n            // plugin told us that it was going to (or has) call unloadCtx.processNext()\n            hasRun = true;\n          }\n        }\n      }\n      return hasRun;\n    }\n    if (!_processChain(updateCtx, _callUpdate, \"update\", function () {}, false)) {\n      // Only called if we hasRun was not true\n      updateCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);\n    }\n  }\n  return objFreeze(proxyChain);\n}\n/**\r\n * This class will be removed!\r\n * @deprecated use createProcessTelemetryContext() instead\r\n */\nvar ProcessTelemetryContext = /** @class */function () {\n  /**\r\n   * Creates a new Telemetry Item context with the current config, core and plugin execution chain\r\n   * @param plugins - The plugin instances that will be executed\r\n   * @param config - The current config\r\n   * @param core - The current core instance\r\n   */\n  function ProcessTelemetryContext(pluginChain, config, core, startAt) {\n    var _self = this;\n    var context = createProcessTelemetryContext(pluginChain, config, core, startAt);\n    // Proxy all functions of the context to this object\n    proxyFunctions(_self, context, objKeys(context));\n  }\n  return ProcessTelemetryContext;\n}();\nexport { ProcessTelemetryContext };","map":{"version":3,"names":["_DYN_CALL","_DYN_CONFIG","_DYN_CREATE_NEW","_DYN_DIAG_LOG","_DYN_GET_NEXT","_DYN_GET_PLUGIN","_DYN_IDENTIFIER","_DYN_IS_ASYNC","_DYN_IS_INITIALIZED","_DYN_LENGTH","_DYN_LOGGER","_DYN_PROCESS_NEXT","_DYN_PUSH","_DYN_SET_NEXT_PLUGIN","_DYN_TEARDOWN","_DYN_UPDATE","_throwInternal","safeGetLogger","dumpObj","arrForEach","isArray","isFunction","isNullOrUndefined","isObject","isUndefined","objExtend","objForEachKey","objFreeze","objKeys","proxyFunctions","STR_CORE","STR_DISABLED","STR_EMPTY","STR_EXTENSION_CONFIG","STR_PRIORITY","STR_PROCESS_TELEMETRY","doPerf","_getPluginState","strTelemetryPluginChain","strHasRunFlags","strGetTelCtx","_chainId","_getNextProxyStart","proxy","core","startAt","createTelemetryProxyChain","_createInternalContext","telemetryChain","config","_nextProxy","_onComplete","context","_next","_moveNext","ctx","diagLog","getCfg","getExtCfg","_getExtCfg","getConfig","_getConfig","hasNext","getNext","setNext","nextPlugin","iterate","_iterateChain","onComplete","_addOnComplete","that","args","_i","arguments","length","func","self","nextProxy","completeDetails","e","identifier","defaultValue","mergeDefault","theConfig","extConfig","newConfig_1","field","cfgValue","theValue","cb","plugin","createProcessTelemetryContext","internalContext","_processNext","env","_createNew","plugins","createProcessTelemetryUnloadContext","unloadState","unload","createProcessTelemetryUpdateContext","updateState","firstProxy","add","lastProxy_1","thePlugin","newProxy","createTelemetryPluginProxy","_setNext","hasProcessTelemetry","hasSetNext","chainId","proxyChain","getPlugin","processTelemetry","_processTelemetry","_unloadPlugin","update","_updatePlugin","_id","_getTelCtx","itemCtx","_processChain","processPluginFn","name","details","isAsync","hasRun","hasRunContext","nextId","error","hasNextRun","_callProcessTelemetry","pluginState","item","sync","unloadCtx","_callTeardown","pluginCore","updateCtx","_callUpdate","ProcessTelemetryContext","pluginChain","_self"],"sources":["/Users/evaristlobo/Documents/GitHub/jhipster-sample-application/client/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/ProcessTelemetryContext.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nimport { _DYN_CALL, _DYN_CONFIG, _DYN_CREATE_NEW, _DYN_DIAG_LOG, _DYN_GET_NEXT, _DYN_GET_PLUGIN, _DYN_IDENTIFIER, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_LOGGER, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_SET_NEXT_PLUGIN, _DYN_TEARDOWN, _DYN_UPDATE } from \"../__DynamicConstants\";\r\nimport { _throwInternal, safeGetLogger } from \"./DiagnosticLogger\";\r\nimport { dumpObj } from \"./EnvUtils\";\r\nimport { arrForEach, isArray, isFunction, isNullOrUndefined, isObject, isUndefined, objExtend, objForEachKey, objFreeze, objKeys, proxyFunctions } from \"./HelperFuncs\";\r\nimport { STR_CORE, STR_DISABLED, STR_EMPTY, STR_EXTENSION_CONFIG, STR_PRIORITY, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\r\nimport { doPerf } from \"./PerfManager\";\r\nimport { _getPluginState } from \"./TelemetryHelpers\";\r\nvar strTelemetryPluginChain = \"TelemetryPluginChain\";\r\nvar strHasRunFlags = \"_hasRun\";\r\nvar strGetTelCtx = \"_getTelCtx\";\r\nvar _chainId = 0;\r\nfunction _getNextProxyStart(proxy, core, startAt) {\r\n    while (proxy) {\r\n        if (proxy[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]() === startAt) {\r\n            return proxy;\r\n        }\r\n        proxy = proxy[_DYN_GET_NEXT /* @min:%2egetNext */]();\r\n    }\r\n    // This wasn't found in the existing chain so create an isolated one with just this plugin\r\n    return createTelemetryProxyChain([startAt], core[_DYN_CONFIG /* @min:%2econfig */] || {}, core);\r\n}\r\n/**\r\n * @ignore\r\n * @param telemetryChain\r\n * @param config\r\n * @param core\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n * @returns\r\n */\r\nfunction _createInternalContext(telemetryChain, config, core, startAt) {\r\n    // We have a special case where we want to start execution from this specific plugin\r\n    // or we simply reuse the existing telemetry plugin chain (normal execution case)\r\n    var _nextProxy = null; // By Default set as no next plugin\r\n    var _onComplete = [];\r\n    if (startAt !== null) {\r\n        // There is no next element (null) vs not defined (undefined) so use the full chain\r\n        _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;\r\n    }\r\n    var context = {\r\n        _next: _moveNext,\r\n        ctx: {\r\n            core: function () {\r\n                return core;\r\n            },\r\n            diagLog: function () {\r\n                return safeGetLogger(core, config);\r\n            },\r\n            getCfg: function () {\r\n                return config;\r\n            },\r\n            getExtCfg: _getExtCfg,\r\n            getConfig: _getConfig,\r\n            hasNext: function () {\r\n                return !!_nextProxy;\r\n            },\r\n            getNext: function () {\r\n                return _nextProxy;\r\n            },\r\n            setNext: function (nextPlugin) {\r\n                _nextProxy = nextPlugin;\r\n            },\r\n            iterate: _iterateChain,\r\n            onComplete: _addOnComplete\r\n        }\r\n    };\r\n    function _addOnComplete(onComplete, that) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        if (onComplete) {\r\n            _onComplete[_DYN_PUSH /* @min:%2epush */]({\r\n                func: onComplete,\r\n                self: !isUndefined(that) ? that : context.ctx,\r\n                args: args\r\n            });\r\n        }\r\n    }\r\n    function _moveNext() {\r\n        var nextProxy = _nextProxy;\r\n        // Automatically move to the next plugin\r\n        _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT /* @min:%2egetNext */]() : null;\r\n        if (!nextProxy) {\r\n            var onComplete = _onComplete;\r\n            if (onComplete && onComplete[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                arrForEach(onComplete, function (completeDetails) {\r\n                    try {\r\n                        completeDetails.func[_DYN_CALL /* @min:%2ecall */](completeDetails.self, completeDetails.args);\r\n                    }\r\n                    catch (e) {\r\n                        _throwInternal(core[_DYN_LOGGER /* @min:%2elogger */], 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, \"Unexpected Exception during onComplete - \" + dumpObj(e));\r\n                    }\r\n                });\r\n                _onComplete = [];\r\n            }\r\n        }\r\n        return nextProxy;\r\n    }\r\n    function _getExtCfg(identifier, defaultValue, mergeDefault) {\r\n        if (defaultValue === void 0) { defaultValue = {}; }\r\n        if (mergeDefault === void 0) { mergeDefault = 0 /* GetExtCfgMergeType.None */; }\r\n        var theConfig;\r\n        if (config) {\r\n            var extConfig = config[STR_EXTENSION_CONFIG /* @min:%2eextensionConfig */];\r\n            if (extConfig && identifier) {\r\n                theConfig = extConfig[identifier];\r\n            }\r\n        }\r\n        if (!theConfig) {\r\n            // Just use the defaults\r\n            theConfig = defaultValue;\r\n        }\r\n        else if (isObject(defaultValue)) {\r\n            if (mergeDefault !== 0 /* GetExtCfgMergeType.None */) {\r\n                // Merge the defaults and configured values\r\n                var newConfig_1 = objExtend(true, defaultValue, theConfig);\r\n                if (config && mergeDefault === 2 /* GetExtCfgMergeType.MergeDefaultFromRootOrDefault */) {\r\n                    // Enumerate over the defaultValues and if not already populated attempt to\r\n                    // find a value from the root config\r\n                    objForEachKey(defaultValue, function (field) {\r\n                        // for each unspecified field, set the default value\r\n                        if (isNullOrUndefined(newConfig_1[field])) {\r\n                            var cfgValue = config[field];\r\n                            if (!isNullOrUndefined(cfgValue)) {\r\n                                newConfig_1[field] = cfgValue;\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                theConfig = newConfig_1;\r\n            }\r\n        }\r\n        return theConfig;\r\n    }\r\n    function _getConfig(identifier, field, defaultValue) {\r\n        if (defaultValue === void 0) { defaultValue = false; }\r\n        var theValue;\r\n        var extConfig = _getExtCfg(identifier, null);\r\n        if (extConfig && !isNullOrUndefined(extConfig[field])) {\r\n            theValue = extConfig[field];\r\n        }\r\n        else if (config && !isNullOrUndefined(config[field])) {\r\n            theValue = config[field];\r\n        }\r\n        return !isNullOrUndefined(theValue) ? theValue : defaultValue;\r\n    }\r\n    function _iterateChain(cb) {\r\n        // Keep processing until we reach the end of the chain\r\n        var nextPlugin;\r\n        while (!!(nextPlugin = context._next())) {\r\n            var plugin = nextPlugin[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]();\r\n            if (plugin) {\r\n                // callback with the current on\r\n                cb(plugin);\r\n            }\r\n        }\r\n    }\r\n    return context;\r\n}\r\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\r\nexport function createProcessTelemetryContext(telemetryChain, config, core, startAt) {\r\n    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\r\n    var context = internalContext.ctx;\r\n    function _processNext(env) {\r\n        var nextPlugin = internalContext._next();\r\n        // Run the next plugin which will call \"processNext()\"\r\n        nextPlugin && nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, context);\r\n        return !nextPlugin;\r\n    }\r\n    function _createNew(plugins, startAt) {\r\n        if (plugins === void 0) { plugins = null; }\r\n        if (isArray(plugins)) {\r\n            plugins = createTelemetryProxyChain(plugins, config, core, startAt);\r\n        }\r\n        return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), config, core, startAt);\r\n    }\r\n    context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\r\n    context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\r\n    return context;\r\n}\r\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain for handling the unloading of the chain\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\r\nexport function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {\r\n    var config = core[_DYN_CONFIG /* @min:%2econfig */] || {};\r\n    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\r\n    var context = internalContext.ctx;\r\n    function _processNext(unloadState) {\r\n        var nextPlugin = internalContext._next();\r\n        nextPlugin && nextPlugin.unload(context, unloadState);\r\n        return !nextPlugin;\r\n    }\r\n    function _createNew(plugins, startAt) {\r\n        if (plugins === void 0) { plugins = null; }\r\n        if (isArray(plugins)) {\r\n            plugins = createTelemetryProxyChain(plugins, config, core, startAt);\r\n        }\r\n        return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);\r\n    }\r\n    context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\r\n    context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\r\n    return context;\r\n}\r\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain for updating the configuration\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\r\nexport function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {\r\n    var config = core[_DYN_CONFIG /* @min:%2econfig */] || {};\r\n    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\r\n    var context = internalContext.ctx;\r\n    function _processNext(updateState) {\r\n        return context.iterate(function (plugin) {\r\n            if (isFunction(plugin[_DYN_UPDATE /* @min:%2eupdate */])) {\r\n                plugin[_DYN_UPDATE /* @min:%2eupdate */](context, updateState);\r\n            }\r\n        });\r\n    }\r\n    function _createNew(plugins, startAt) {\r\n        if (plugins === void 0) { plugins = null; }\r\n        if (isArray(plugins)) {\r\n            plugins = createTelemetryProxyChain(plugins, config, core, startAt);\r\n        }\r\n        return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);\r\n    }\r\n    context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\r\n    context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\r\n    return context;\r\n}\r\n/**\r\n * Creates an execution chain from the array of plugins\r\n * @param plugins - The array of plugins that will be executed in this order\r\n * @param defItemCtx - The default execution context to use when no telemetry context is passed to processTelemetry(), this\r\n * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error\r\n * reporting (hasRun) when errors occur.\r\n */\r\nexport function createTelemetryProxyChain(plugins, config, core, startAt) {\r\n    var firstProxy = null;\r\n    var add = startAt ? false : true;\r\n    if (isArray(plugins) && plugins[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n        // Create the proxies and wire up the next plugin chain\r\n        var lastProxy_1 = null;\r\n        arrForEach(plugins, function (thePlugin) {\r\n            if (!add && startAt === thePlugin) {\r\n                add = true;\r\n            }\r\n            if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\r\n                // Only add plugins that are processors\r\n                var newProxy = createTelemetryPluginProxy(thePlugin, config, core);\r\n                if (!firstProxy) {\r\n                    firstProxy = newProxy;\r\n                }\r\n                if (lastProxy_1) {\r\n                    // Set this new proxy as the next for the previous one\r\n                    lastProxy_1._setNext(newProxy);\r\n                }\r\n                lastProxy_1 = newProxy;\r\n            }\r\n        });\r\n    }\r\n    if (startAt && !firstProxy) {\r\n        // Special case where the \"startAt\" was not in the original list of plugins\r\n        return createTelemetryProxyChain([startAt], config, core);\r\n    }\r\n    return firstProxy;\r\n}\r\n/**\r\n * Create the processing telemetry proxy instance, the proxy is used to abstract the current plugin to allow monitoring and\r\n * execution plugins while passing around the dynamic execution state (IProcessTelemetryContext), the proxy instance no longer\r\n * contains any execution state and can be reused between requests (this was not the case for 2.7.2 and earlier with the\r\n * TelemetryPluginChain class).\r\n * @param plugin - The plugin instance to proxy\r\n * @param config - The default execution context to use when no telemetry context is passed to processTelemetry(), this\r\n * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error\r\n * reporting (hasRun) when errors occur.\r\n * @returns\r\n */\r\nexport function createTelemetryPluginProxy(plugin, config, core) {\r\n    var nextProxy = null;\r\n    var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]);\r\n    var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */]);\r\n    var chainId;\r\n    if (plugin) {\r\n        chainId = plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"-\" + plugin[STR_PRIORITY /* @min:%2epriority */] + \"-\" + _chainId++;\r\n    }\r\n    else {\r\n        chainId = \"Unknown-0-\" + _chainId++;\r\n    }\r\n    var proxyChain = {\r\n        getPlugin: function () {\r\n            return plugin;\r\n        },\r\n        getNext: function () {\r\n            return nextProxy;\r\n        },\r\n        processTelemetry: _processTelemetry,\r\n        unload: _unloadPlugin,\r\n        update: _updatePlugin,\r\n        _id: chainId,\r\n        _setNext: function (nextPlugin) {\r\n            nextProxy = nextPlugin;\r\n        }\r\n    };\r\n    function _getTelCtx() {\r\n        var itemCtx;\r\n        // Looks like a plugin didn't pass the (optional) context, so create a new one\r\n        if (plugin && isFunction(plugin[strGetTelCtx])) {\r\n            // This plugin extends from the BaseTelemetryPlugin so lets use it\r\n            itemCtx = plugin[strGetTelCtx]();\r\n        }\r\n        if (!itemCtx) {\r\n            // Create a temporary one\r\n            itemCtx = createProcessTelemetryContext(proxyChain, config, core);\r\n        }\r\n        return itemCtx;\r\n    }\r\n    function _processChain(itemCtx, processPluginFn, name, details, isAsync) {\r\n        var hasRun = false;\r\n        var identifier = plugin ? plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] : strTelemetryPluginChain;\r\n        var hasRunContext = itemCtx[strHasRunFlags];\r\n        if (!hasRunContext) {\r\n            // Assign and populate\r\n            hasRunContext = itemCtx[strHasRunFlags] = {};\r\n        }\r\n        // Ensure that we keep the context in sync\r\n        itemCtx.setNext(nextProxy);\r\n        if (plugin) {\r\n            doPerf(itemCtx[STR_CORE /* @min:%2ecore */](), function () { return identifier + \":\" + name; }, function () {\r\n                // Mark this component as having run\r\n                hasRunContext[chainId] = true;\r\n                try {\r\n                    // Set a flag on the next plugin so we know if it was attempted to be executed\r\n                    var nextId = nextProxy ? nextProxy._id : STR_EMPTY;\r\n                    if (nextId) {\r\n                        hasRunContext[nextId] = false;\r\n                    }\r\n                    hasRun = processPluginFn(itemCtx);\r\n                }\r\n                catch (error) {\r\n                    var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;\r\n                    if (hasNextRun) {\r\n                        // The next plugin after us has already run so set this one as complete\r\n                        hasRun = true;\r\n                    }\r\n                    if (!nextProxy || !hasNextRun) {\r\n                        // Either we have no next plugin or the current one did not attempt to call the next plugin\r\n                        // Which means the current one is the root of the failure so log/report this failure\r\n                        _throwInternal(itemCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 73 /* _eInternalMessageId.PluginException */, \"Plugin [\" + identifier + \"] failed during \" + name + \" - \" + dumpObj(error) + \", run flags: \" + dumpObj(hasRunContext));\r\n                    }\r\n                }\r\n            }, details, isAsync);\r\n        }\r\n        return hasRun;\r\n    }\r\n    function _processTelemetry(env, itemCtx) {\r\n        itemCtx = itemCtx || _getTelCtx();\r\n        function _callProcessTelemetry(itemCtx) {\r\n            if (!plugin || !hasProcessTelemetry) {\r\n                return false;\r\n            }\r\n            var pluginState = _getPluginState(plugin);\r\n            if (pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] || pluginState[STR_DISABLED]) {\r\n                return false;\r\n            }\r\n            // Ensure that we keep the context in sync (for processNext()), just in case a plugin\r\n            // doesn't calls processTelemetry() instead of itemContext.processNext() or some\r\n            // other form of error occurred\r\n            if (hasSetNext) {\r\n                // Backward compatibility setting the next plugin on the instance\r\n                plugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](nextProxy);\r\n            }\r\n            plugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, itemCtx);\r\n            // Process Telemetry is expected to call itemCtx.processNext() or nextPlugin.processTelemetry()\r\n            return true;\r\n        }\r\n        if (!_processChain(itemCtx, _callProcessTelemetry, \"processTelemetry\", function () { return ({ item: env }); }, !(env.sync))) {\r\n            // The underlying plugin is either not defined, not enabled or does not have a processTelemetry implementation\r\n            // so we still want the next plugin to be executed.\r\n            itemCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);\r\n        }\r\n    }\r\n    function _unloadPlugin(unloadCtx, unloadState) {\r\n        function _callTeardown() {\r\n            // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().\r\n            var hasRun = false;\r\n            if (plugin) {\r\n                var pluginState = _getPluginState(plugin);\r\n                var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE /* @min:%2ecore */];\r\n                // Only teardown the plugin if it was initialized by the current core (i.e. It's not a shared plugin)\r\n                if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */]) {\r\n                    // Handle plugins that don't extend from the BaseTelemetryPlugin\r\n                    pluginState[STR_CORE /* @min:%2ecore */] = null;\r\n                    pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] = true;\r\n                    pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = false;\r\n                    if (plugin[_DYN_TEARDOWN /* @min:%2eteardown */] && plugin[_DYN_TEARDOWN /* @min:%2eteardown */](unloadCtx, unloadState) === true) {\r\n                        // plugin told us that it was going to (or has) call unloadCtx.processNext()\r\n                        hasRun = true;\r\n                    }\r\n                }\r\n            }\r\n            return hasRun;\r\n        }\r\n        if (!_processChain(unloadCtx, _callTeardown, \"unload\", function () { }, unloadState[_DYN_IS_ASYNC /* @min:%2eisAsync */])) {\r\n            // Only called if we hasRun was not true\r\n            unloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\r\n        }\r\n    }\r\n    function _updatePlugin(updateCtx, updateState) {\r\n        function _callUpdate() {\r\n            // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().\r\n            var hasRun = false;\r\n            if (plugin) {\r\n                var pluginState = _getPluginState(plugin);\r\n                var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE /* @min:%2ecore */];\r\n                // Only update the plugin if it was initialized by the current core (i.e. It's not a shared plugin)\r\n                if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */]) {\r\n                    if (plugin[_DYN_UPDATE /* @min:%2eupdate */] && plugin[_DYN_UPDATE /* @min:%2eupdate */](updateCtx, updateState) === true) {\r\n                        // plugin told us that it was going to (or has) call unloadCtx.processNext()\r\n                        hasRun = true;\r\n                    }\r\n                }\r\n            }\r\n            return hasRun;\r\n        }\r\n        if (!_processChain(updateCtx, _callUpdate, \"update\", function () { }, false)) {\r\n            // Only called if we hasRun was not true\r\n            updateCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);\r\n        }\r\n    }\r\n    return objFreeze(proxyChain);\r\n}\r\n/**\r\n * This class will be removed!\r\n * @deprecated use createProcessTelemetryContext() instead\r\n */\r\nvar ProcessTelemetryContext = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Telemetry Item context with the current config, core and plugin execution chain\r\n     * @param plugins - The plugin instances that will be executed\r\n     * @param config - The current config\r\n     * @param core - The current core instance\r\n     */\r\n    function ProcessTelemetryContext(pluginChain, config, core, startAt) {\r\n        var _self = this;\r\n        var context = createProcessTelemetryContext(pluginChain, config, core, startAt);\r\n        // Proxy all functions of the context to this object\r\n        proxyFunctions(_self, context, objKeys(context));\r\n    }\r\n    return ProcessTelemetryContext;\r\n}());\r\nexport { ProcessTelemetryContext };\r\n//# sourceMappingURL=ProcessTelemetryContext.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}