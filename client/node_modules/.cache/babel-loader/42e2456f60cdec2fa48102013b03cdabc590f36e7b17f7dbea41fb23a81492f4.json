{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 2.8.12\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { _DYN_DIAG_LOG, _DYN_ENABLE_DEBUG_EXCEPTI4, _DYN_LOGGER, _DYN_LOG_INTERNAL_MESSAGE, _DYN_MESSAGE, _DYN_MESSAGE_ID, _DYN_PUSH, _DYN_REPLACE } from \"../__DynamicConstants\";\nimport { getDebugExt } from \"./DbgExtensionUtils\";\nimport { dumpObj, getConsole, getJSON, hasJSON } from \"./EnvUtils\";\nimport { getCfgValue, isFunction, isUndefined } from \"./HelperFuncs\";\nimport { STR_EMPTY, STR_ERROR_TO_CONSOLE, STR_WARN_TO_CONSOLE } from \"./InternalConstants\";\n/**\r\n * For user non actionable traces use AI Internal prefix.\r\n */\nvar AiNonUserActionablePrefix = \"AI (Internal): \";\n/**\r\n * Prefix of the traces in portal.\r\n */\nvar AiUserActionablePrefix = \"AI: \";\n/**\r\n *  Session storage key for the prefix for the key indicating message type already logged\r\n */\nvar AIInternalMessagePrefix = \"AITR_\";\nfunction _sanitizeDiagnosticText(text) {\n  if (text) {\n    return \"\\\"\" + text[_DYN_REPLACE /* @min:%2ereplace */](/\\\"/g, STR_EMPTY) + \"\\\"\";\n  }\n  return STR_EMPTY;\n}\nfunction _logToConsole(func, message) {\n  var theConsole = getConsole();\n  if (!!theConsole) {\n    var logFunc = \"log\";\n    if (theConsole[func]) {\n      logFunc = func;\n    }\n    if (isFunction(theConsole[logFunc])) {\n      theConsole[logFunc](message);\n    }\n  }\n}\nvar _InternalLogMessage = /** @class */function () {\n  function _InternalLogMessage(msgId, msg, isUserAct, properties) {\n    if (isUserAct === void 0) {\n      isUserAct = false;\n    }\n    var _self = this;\n    _self[_DYN_MESSAGE_ID /* @min:%2emessageId */] = msgId;\n    _self[_DYN_MESSAGE /* @min:%2emessage */] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;\n    var strProps = STR_EMPTY;\n    if (hasJSON()) {\n      strProps = getJSON().stringify(properties);\n    }\n    var diagnosticText = (msg ? \" message:\" + _sanitizeDiagnosticText(msg) : STR_EMPTY) + (properties ? \" props:\" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);\n    _self[_DYN_MESSAGE /* @min:%2emessage */] += diagnosticText;\n  }\n  _InternalLogMessage.dataType = \"MessageData\";\n  return _InternalLogMessage;\n}();\nexport { _InternalLogMessage };\nexport function safeGetLogger(core, config) {\n  return (core || {})[_DYN_LOGGER /* @min:%2elogger */] || new DiagnosticLogger(config);\n}\nvar DiagnosticLogger = /** @class */function () {\n  function DiagnosticLogger(config) {\n    this.identifier = \"DiagnosticLogger\";\n    /**\r\n     * The internal logging queue\r\n     */\n    this.queue = [];\n    /**\r\n     * Count of internal messages sent\r\n     */\n    var _messageCount = 0;\n    /**\r\n     * Holds information about what message types were already logged to console or sent to server.\r\n     */\n    var _messageLogged = {};\n    var _loggingLevelConsole;\n    var _loggingLevelTelemetry;\n    var _maxInternalMessageLimit;\n    var _enableDebug;\n    dynamicProto(DiagnosticLogger, this, function (_self) {\n      _setDefaultsFromConfig(config || {});\n      _self.consoleLoggingLevel = function () {\n        return _loggingLevelConsole;\n      };\n      _self.telemetryLoggingLevel = function () {\n        return _loggingLevelTelemetry;\n      };\n      _self.maxInternalMessageLimit = function () {\n        return _maxInternalMessageLimit;\n      };\n      _self[_DYN_ENABLE_DEBUG_EXCEPTI4 /* @min:%2eenableDebugExceptions */] = function () {\n        return _enableDebug;\n      };\n      /**\r\n       * This method will throw exceptions in debug mode or attempt to log the error as a console warning.\r\n       * @param severity {LoggingSeverity} - The severity of the log message\r\n       * @param message {_InternalLogMessage} - The log message.\r\n       */\n      _self.throwInternal = function (severity, msgId, msg, properties, isUserAct) {\n        if (isUserAct === void 0) {\n          isUserAct = false;\n        }\n        var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);\n        if (_enableDebug) {\n          throw dumpObj(message);\n        } else {\n          // Get the logging function and fallback to warnToConsole of for some reason errorToConsole doesn't exist\n          var logFunc = severity === 1 /* eLoggingSeverity.CRITICAL */ ? STR_ERROR_TO_CONSOLE : STR_WARN_TO_CONSOLE;\n          if (!isUndefined(message[_DYN_MESSAGE /* @min:%2emessage */])) {\n            if (isUserAct) {\n              // check if this message type was already logged to console for this page view and if so, don't log it again\n              var messageKey = +message[_DYN_MESSAGE_ID /* @min:%2emessageId */];\n              if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {\n                _self[logFunc](message[_DYN_MESSAGE /* @min:%2emessage */]);\n                _messageLogged[messageKey] = true;\n              }\n            } else {\n              // Only log traces if the console Logging Level is >= the throwInternal severity level\n              if (_loggingLevelConsole >= severity) {\n                _self[logFunc](message[_DYN_MESSAGE /* @min:%2emessage */]);\n              }\n            }\n\n            _logInternalMessage(severity, message);\n          } else {\n            _debugExtMsg(\"throw\" + (severity === 1 /* eLoggingSeverity.CRITICAL */ ? \"Critical\" : \"Warning\"), message);\n          }\n        }\n      };\n      /**\r\n       * This will write a warning to the console if possible\r\n       * @param message {string} - The warning message\r\n       */\n      _self[STR_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */] = function (message) {\n        _logToConsole(\"warn\", message);\n        _debugExtMsg(\"warning\", message);\n      };\n      /**\r\n       * This will write an error to the console if possible\r\n       * @param message {string} - The error message\r\n       */\n      _self[STR_ERROR_TO_CONSOLE /* @min:%2eerrorToConsole */] = function (message) {\n        _logToConsole(\"error\", message);\n        _debugExtMsg(\"error\", message);\n      };\n      /**\r\n       * Resets the internal message count\r\n       */\n      _self.resetInternalMessageCount = function () {\n        _messageCount = 0;\n        _messageLogged = {};\n      };\n      /**\r\n       * Logs a message to the internal queue.\r\n       * @param severity {LoggingSeverity} - The severity of the log message\r\n       * @param message {_InternalLogMessage} - The message to log.\r\n       */\n      _self[_DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */] = _logInternalMessage;\n      function _logInternalMessage(severity, message) {\n        if (_areInternalMessagesThrottled()) {\n          return;\n        }\n        // check if this message type was already logged for this session and if so, don't log it again\n        var logMessage = true;\n        var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID /* @min:%2emessageId */];\n        // if the session storage is not available, limit to only one message type per page view\n        if (_messageLogged[messageKey]) {\n          logMessage = false;\n        } else {\n          _messageLogged[messageKey] = true;\n        }\n        if (logMessage) {\n          // Push the event in the internal queue\n          if (severity <= _loggingLevelTelemetry) {\n            _self.queue[_DYN_PUSH /* @min:%2epush */](message);\n            _messageCount++;\n            _debugExtMsg(severity === 1 /* eLoggingSeverity.CRITICAL */ ? \"error\" : \"warn\", message);\n          }\n          // When throttle limit reached, send a special event\n          if (_messageCount === _maxInternalMessageLimit) {\n            var throttleLimitMessage = \"Internal events throttle limit per PageView reached for this app.\";\n            var throttleMessage = new _InternalLogMessage(23 /* _eInternalMessageId.MessageLimitPerPVExceeded */, throttleLimitMessage, false);\n            _self.queue[_DYN_PUSH /* @min:%2epush */](throttleMessage);\n            if (severity === 1 /* eLoggingSeverity.CRITICAL */) {\n              _self[STR_ERROR_TO_CONSOLE /* @min:%2eerrorToConsole */](throttleLimitMessage);\n            } else {\n              _self[STR_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](throttleLimitMessage);\n            }\n          }\n        }\n      }\n      function _setDefaultsFromConfig(config) {\n        _loggingLevelConsole = getCfgValue(config.loggingLevelConsole, 0);\n        _loggingLevelTelemetry = getCfgValue(config.loggingLevelTelemetry, 1);\n        _maxInternalMessageLimit = getCfgValue(config.maxMessageLimit, 25);\n        _enableDebug = getCfgValue(config.enableDebug, getCfgValue(config[_DYN_ENABLE_DEBUG_EXCEPTI4 /* @min:%2eenableDebugExceptions */], false));\n      }\n      function _areInternalMessagesThrottled() {\n        return _messageCount >= _maxInternalMessageLimit;\n      }\n      function _debugExtMsg(name, data) {\n        var dbgExt = getDebugExt(config || {});\n        if (dbgExt && dbgExt[_DYN_DIAG_LOG /* @min:%2ediagLog */]) {\n          dbgExt[_DYN_DIAG_LOG /* @min:%2ediagLog */](name, data);\n        }\n      }\n    });\n  }\n  // Removed Stub for DiagnosticLogger.prototype.enableDebugExceptions.\n  // Removed Stub for DiagnosticLogger.prototype.consoleLoggingLevel.\n  // Removed Stub for DiagnosticLogger.prototype.telemetryLoggingLevel.\n  // Removed Stub for DiagnosticLogger.prototype.maxInternalMessageLimit.\n  // Removed Stub for DiagnosticLogger.prototype.throwInternal.\n  // Removed Stub for DiagnosticLogger.prototype.warnToConsole.\n  // Removed Stub for DiagnosticLogger.prototype.errorToConsole.\n  // Removed Stub for DiagnosticLogger.prototype.resetInternalMessageCount.\n  // Removed Stub for DiagnosticLogger.prototype.logInternalMessage.\n  // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  // this will be removed when ES3 support is dropped.\n  DiagnosticLogger.__ieDyn = 1;\n  return DiagnosticLogger;\n}();\nexport { DiagnosticLogger };\nfunction _getLogger(logger) {\n  return logger || new DiagnosticLogger();\n}\n/**\r\n * This is a helper method which will call throwInternal on the passed logger, will throw exceptions in\r\n * debug mode or attempt to log the error as a console warning. This helper is provided mostly to better\r\n * support minification as logger.throwInternal() will not compress the publish \"throwInternal\" used throughout\r\n * the code.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param severity {LoggingSeverity} - The severity of the log message\r\n * @param message {_InternalLogMessage} - The log message.\r\n */\nexport function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {\n  if (isUserAct === void 0) {\n    isUserAct = false;\n  }\n  _getLogger(logger).throwInternal(severity, msgId, msg, properties, isUserAct);\n}\n/**\r\n * This is a helper method which will call warnToConsole on the passed logger with the provided message.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param message {_InternalLogMessage} - The log message.\r\n */\nexport function _warnToConsole(logger, message) {\n  _getLogger(logger)[STR_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);\n}\n/**\r\n * Logs a message to the internal queue.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param severity {LoggingSeverity} - The severity of the log message\r\n * @param message {_InternalLogMessage} - The message to log.\r\n */\nexport function _logInternalMessage(logger, severity, message) {\n  _getLogger(logger)[_DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */](severity, message);\n}","map":{"version":3,"names":["dynamicProto","_DYN_DIAG_LOG","_DYN_ENABLE_DEBUG_EXCEPTI4","_DYN_LOGGER","_DYN_LOG_INTERNAL_MESSAGE","_DYN_MESSAGE","_DYN_MESSAGE_ID","_DYN_PUSH","_DYN_REPLACE","getDebugExt","dumpObj","getConsole","getJSON","hasJSON","getCfgValue","isFunction","isUndefined","STR_EMPTY","STR_ERROR_TO_CONSOLE","STR_WARN_TO_CONSOLE","AiNonUserActionablePrefix","AiUserActionablePrefix","AIInternalMessagePrefix","_sanitizeDiagnosticText","text","_logToConsole","func","message","theConsole","logFunc","_InternalLogMessage","msgId","msg","isUserAct","properties","_self","strProps","stringify","diagnosticText","dataType","safeGetLogger","core","config","DiagnosticLogger","identifier","queue","_messageCount","_messageLogged","_loggingLevelConsole","_loggingLevelTelemetry","_maxInternalMessageLimit","_enableDebug","_setDefaultsFromConfig","consoleLoggingLevel","telemetryLoggingLevel","maxInternalMessageLimit","throwInternal","severity","messageKey","_logInternalMessage","_debugExtMsg","resetInternalMessageCount","_areInternalMessagesThrottled","logMessage","throttleLimitMessage","throttleMessage","loggingLevelConsole","loggingLevelTelemetry","maxMessageLimit","enableDebug","name","data","dbgExt","_getLogger","logger","_throwInternal","_warnToConsole"],"sources":["/Users/evaristlobo/Documents/GitHub/jhipster-sample-application/client/node_modules/@microsoft/applicationinsights-core-js/dist-esm/JavaScriptSDK/DiagnosticLogger.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { _DYN_DIAG_LOG, _DYN_ENABLE_DEBUG_EXCEPTI4, _DYN_LOGGER, _DYN_LOG_INTERNAL_MESSAGE, _DYN_MESSAGE, _DYN_MESSAGE_ID, _DYN_PUSH, _DYN_REPLACE } from \"../__DynamicConstants\";\r\nimport { getDebugExt } from \"./DbgExtensionUtils\";\r\nimport { dumpObj, getConsole, getJSON, hasJSON } from \"./EnvUtils\";\r\nimport { getCfgValue, isFunction, isUndefined } from \"./HelperFuncs\";\r\nimport { STR_EMPTY, STR_ERROR_TO_CONSOLE, STR_WARN_TO_CONSOLE } from \"./InternalConstants\";\r\n/**\r\n * For user non actionable traces use AI Internal prefix.\r\n */\r\nvar AiNonUserActionablePrefix = \"AI (Internal): \";\r\n/**\r\n * Prefix of the traces in portal.\r\n */\r\nvar AiUserActionablePrefix = \"AI: \";\r\n/**\r\n *  Session storage key for the prefix for the key indicating message type already logged\r\n */\r\nvar AIInternalMessagePrefix = \"AITR_\";\r\nfunction _sanitizeDiagnosticText(text) {\r\n    if (text) {\r\n        return \"\\\"\" + text[_DYN_REPLACE /* @min:%2ereplace */](/\\\"/g, STR_EMPTY) + \"\\\"\";\r\n    }\r\n    return STR_EMPTY;\r\n}\r\nfunction _logToConsole(func, message) {\r\n    var theConsole = getConsole();\r\n    if (!!theConsole) {\r\n        var logFunc = \"log\";\r\n        if (theConsole[func]) {\r\n            logFunc = func;\r\n        }\r\n        if (isFunction(theConsole[logFunc])) {\r\n            theConsole[logFunc](message);\r\n        }\r\n    }\r\n}\r\nvar _InternalLogMessage = /** @class */ (function () {\r\n    function _InternalLogMessage(msgId, msg, isUserAct, properties) {\r\n        if (isUserAct === void 0) { isUserAct = false; }\r\n        var _self = this;\r\n        _self[_DYN_MESSAGE_ID /* @min:%2emessageId */] = msgId;\r\n        _self[_DYN_MESSAGE /* @min:%2emessage */] =\r\n            (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) +\r\n                msgId;\r\n        var strProps = STR_EMPTY;\r\n        if (hasJSON()) {\r\n            strProps = getJSON().stringify(properties);\r\n        }\r\n        var diagnosticText = (msg ? \" message:\" + _sanitizeDiagnosticText(msg) : STR_EMPTY) +\r\n            (properties ? \" props:\" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);\r\n        _self[_DYN_MESSAGE /* @min:%2emessage */] += diagnosticText;\r\n    }\r\n    _InternalLogMessage.dataType = \"MessageData\";\r\n    return _InternalLogMessage;\r\n}());\r\nexport { _InternalLogMessage };\r\nexport function safeGetLogger(core, config) {\r\n    return (core || {})[_DYN_LOGGER /* @min:%2elogger */] || new DiagnosticLogger(config);\r\n}\r\nvar DiagnosticLogger = /** @class */ (function () {\r\n    function DiagnosticLogger(config) {\r\n        this.identifier = \"DiagnosticLogger\";\r\n        /**\r\n         * The internal logging queue\r\n         */\r\n        this.queue = [];\r\n        /**\r\n         * Count of internal messages sent\r\n         */\r\n        var _messageCount = 0;\r\n        /**\r\n         * Holds information about what message types were already logged to console or sent to server.\r\n         */\r\n        var _messageLogged = {};\r\n        var _loggingLevelConsole;\r\n        var _loggingLevelTelemetry;\r\n        var _maxInternalMessageLimit;\r\n        var _enableDebug;\r\n        dynamicProto(DiagnosticLogger, this, function (_self) {\r\n            _setDefaultsFromConfig(config || {});\r\n            _self.consoleLoggingLevel = function () { return _loggingLevelConsole; };\r\n            _self.telemetryLoggingLevel = function () { return _loggingLevelTelemetry; };\r\n            _self.maxInternalMessageLimit = function () { return _maxInternalMessageLimit; };\r\n            _self[_DYN_ENABLE_DEBUG_EXCEPTI4 /* @min:%2eenableDebugExceptions */] = function () { return _enableDebug; };\r\n            /**\r\n             * This method will throw exceptions in debug mode or attempt to log the error as a console warning.\r\n             * @param severity {LoggingSeverity} - The severity of the log message\r\n             * @param message {_InternalLogMessage} - The log message.\r\n             */\r\n            _self.throwInternal = function (severity, msgId, msg, properties, isUserAct) {\r\n                if (isUserAct === void 0) { isUserAct = false; }\r\n                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);\r\n                if (_enableDebug) {\r\n                    throw dumpObj(message);\r\n                }\r\n                else {\r\n                    // Get the logging function and fallback to warnToConsole of for some reason errorToConsole doesn't exist\r\n                    var logFunc = severity === 1 /* eLoggingSeverity.CRITICAL */ ? STR_ERROR_TO_CONSOLE : STR_WARN_TO_CONSOLE;\r\n                    if (!isUndefined(message[_DYN_MESSAGE /* @min:%2emessage */])) {\r\n                        if (isUserAct) {\r\n                            // check if this message type was already logged to console for this page view and if so, don't log it again\r\n                            var messageKey = +message[_DYN_MESSAGE_ID /* @min:%2emessageId */];\r\n                            if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {\r\n                                _self[logFunc](message[_DYN_MESSAGE /* @min:%2emessage */]);\r\n                                _messageLogged[messageKey] = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Only log traces if the console Logging Level is >= the throwInternal severity level\r\n                            if (_loggingLevelConsole >= severity) {\r\n                                _self[logFunc](message[_DYN_MESSAGE /* @min:%2emessage */]);\r\n                            }\r\n                        }\r\n                        _logInternalMessage(severity, message);\r\n                    }\r\n                    else {\r\n                        _debugExtMsg(\"throw\" + (severity === 1 /* eLoggingSeverity.CRITICAL */ ? \"Critical\" : \"Warning\"), message);\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             * This will write a warning to the console if possible\r\n             * @param message {string} - The warning message\r\n             */\r\n            _self[STR_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */] = function (message) {\r\n                _logToConsole(\"warn\", message);\r\n                _debugExtMsg(\"warning\", message);\r\n            };\r\n            /**\r\n             * This will write an error to the console if possible\r\n             * @param message {string} - The error message\r\n             */\r\n            _self[STR_ERROR_TO_CONSOLE /* @min:%2eerrorToConsole */] = function (message) {\r\n                _logToConsole(\"error\", message);\r\n                _debugExtMsg(\"error\", message);\r\n            };\r\n            /**\r\n             * Resets the internal message count\r\n             */\r\n            _self.resetInternalMessageCount = function () {\r\n                _messageCount = 0;\r\n                _messageLogged = {};\r\n            };\r\n            /**\r\n             * Logs a message to the internal queue.\r\n             * @param severity {LoggingSeverity} - The severity of the log message\r\n             * @param message {_InternalLogMessage} - The message to log.\r\n             */\r\n            _self[_DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */] = _logInternalMessage;\r\n            function _logInternalMessage(severity, message) {\r\n                if (_areInternalMessagesThrottled()) {\r\n                    return;\r\n                }\r\n                // check if this message type was already logged for this session and if so, don't log it again\r\n                var logMessage = true;\r\n                var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID /* @min:%2emessageId */];\r\n                // if the session storage is not available, limit to only one message type per page view\r\n                if (_messageLogged[messageKey]) {\r\n                    logMessage = false;\r\n                }\r\n                else {\r\n                    _messageLogged[messageKey] = true;\r\n                }\r\n                if (logMessage) {\r\n                    // Push the event in the internal queue\r\n                    if (severity <= _loggingLevelTelemetry) {\r\n                        _self.queue[_DYN_PUSH /* @min:%2epush */](message);\r\n                        _messageCount++;\r\n                        _debugExtMsg((severity === 1 /* eLoggingSeverity.CRITICAL */ ? \"error\" : \"warn\"), message);\r\n                    }\r\n                    // When throttle limit reached, send a special event\r\n                    if (_messageCount === _maxInternalMessageLimit) {\r\n                        var throttleLimitMessage = \"Internal events throttle limit per PageView reached for this app.\";\r\n                        var throttleMessage = new _InternalLogMessage(23 /* _eInternalMessageId.MessageLimitPerPVExceeded */, throttleLimitMessage, false);\r\n                        _self.queue[_DYN_PUSH /* @min:%2epush */](throttleMessage);\r\n                        if (severity === 1 /* eLoggingSeverity.CRITICAL */) {\r\n                            _self[STR_ERROR_TO_CONSOLE /* @min:%2eerrorToConsole */](throttleLimitMessage);\r\n                        }\r\n                        else {\r\n                            _self[STR_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](throttleLimitMessage);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            function _setDefaultsFromConfig(config) {\r\n                _loggingLevelConsole = getCfgValue(config.loggingLevelConsole, 0);\r\n                _loggingLevelTelemetry = getCfgValue(config.loggingLevelTelemetry, 1);\r\n                _maxInternalMessageLimit = getCfgValue(config.maxMessageLimit, 25);\r\n                _enableDebug = getCfgValue(config.enableDebug, getCfgValue(config[_DYN_ENABLE_DEBUG_EXCEPTI4 /* @min:%2eenableDebugExceptions */], false));\r\n            }\r\n            function _areInternalMessagesThrottled() {\r\n                return _messageCount >= _maxInternalMessageLimit;\r\n            }\r\n            function _debugExtMsg(name, data) {\r\n                var dbgExt = getDebugExt(config || {});\r\n                if (dbgExt && dbgExt[_DYN_DIAG_LOG /* @min:%2ediagLog */]) {\r\n                    dbgExt[_DYN_DIAG_LOG /* @min:%2ediagLog */](name, data);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * When this is true the SDK will throw exceptions to aid in debugging.\r\n     */\r\n    DiagnosticLogger.prototype.enableDebugExceptions = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return false;\r\n    };\r\n    /**\r\n     * 0: OFF (default)\r\n     * 1: CRITICAL\r\n     * 2: >= WARNING\r\n     */\r\n    DiagnosticLogger.prototype.consoleLoggingLevel = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return 0;\r\n    };\r\n    /**\r\n     * 0: OFF\r\n     * 1: CRITICAL (default)\r\n     * 2: >= WARNING\r\n     */\r\n    DiagnosticLogger.prototype.telemetryLoggingLevel = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return 1;\r\n    };\r\n    /**\r\n     * The maximum number of internal messages allowed to be sent per page view\r\n     */\r\n    DiagnosticLogger.prototype.maxInternalMessageLimit = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return 25;\r\n    };\r\n    /**\r\n     * This method will throw exceptions in debug mode or attempt to log the error as a console warning.\r\n     * @param severity {LoggingSeverity} - The severity of the log message\r\n     * @param message {_InternalLogMessage} - The log message.\r\n     */\r\n    DiagnosticLogger.prototype.throwInternal = function (severity, msgId, msg, properties, isUserAct) {\r\n        if (isUserAct === void 0) { isUserAct = false; }\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * This will write a warning to the console if possible\r\n     * @param message {string} - The warning message\r\n     */\r\n    DiagnosticLogger.prototype.warnToConsole = function (message) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * This will write an error to the console if possible\r\n     * @param message {string} - The warning message\r\n     */\r\n    DiagnosticLogger.prototype.errorToConsole = function (message) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Resets the internal message count\r\n     */\r\n    DiagnosticLogger.prototype.resetInternalMessageCount = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Logs a message to the internal queue.\r\n     * @param severity {LoggingSeverity} - The severity of the log message\r\n     * @param message {_InternalLogMessage} - The message to log.\r\n     */\r\n    DiagnosticLogger.prototype.logInternalMessage = function (severity, message) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return DiagnosticLogger;\r\n}());\r\nexport { DiagnosticLogger };\r\nfunction _getLogger(logger) {\r\n    return (logger || new DiagnosticLogger());\r\n}\r\n/**\r\n * This is a helper method which will call throwInternal on the passed logger, will throw exceptions in\r\n * debug mode or attempt to log the error as a console warning. This helper is provided mostly to better\r\n * support minification as logger.throwInternal() will not compress the publish \"throwInternal\" used throughout\r\n * the code.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param severity {LoggingSeverity} - The severity of the log message\r\n * @param message {_InternalLogMessage} - The log message.\r\n */\r\nexport function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {\r\n    if (isUserAct === void 0) { isUserAct = false; }\r\n    _getLogger(logger).throwInternal(severity, msgId, msg, properties, isUserAct);\r\n}\r\n/**\r\n * This is a helper method which will call warnToConsole on the passed logger with the provided message.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param message {_InternalLogMessage} - The log message.\r\n */\r\nexport function _warnToConsole(logger, message) {\r\n    _getLogger(logger)[STR_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);\r\n}\r\n/**\r\n * Logs a message to the internal queue.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param severity {LoggingSeverity} - The severity of the log message\r\n * @param message {_InternalLogMessage} - The message to log.\r\n */\r\nexport function _logInternalMessage(logger, severity, message) {\r\n    _getLogger(logger)[_DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */](severity, message);\r\n}\r\n//# sourceMappingURL=DiagnosticLogger.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}